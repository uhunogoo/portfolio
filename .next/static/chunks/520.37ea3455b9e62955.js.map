{"version":3,"file":"static/chunks/520.37ea3455b9e62955.js","mappings":"+IAUA,IAAAA,EAAA,IAAAC,OAEA,OAAAC,UAA0BC,EAAAC,MAAM,CAEhCC,YAAAC,CAAA,EAEA,MAAAA,GAEA,KAAAC,WAAA,IACA,KAAAC,aAAA,IACA,KAAAC,aAAA,MACA,KAAAC,cAAA,MAEA,KAAAC,WAAA,GACA,KAAAC,UAAA,IACA,KAAAC,gBAAA,GACA,KAAAC,eAAA,IAEA,KAAAC,mBAAA,EACAC,SAAA,WACAC,OAAA,SACAC,MAAA,QACAC,GAAA,WACA,EACA,KAAAC,qBAAA,EACAJ,SAAA,eACAC,OAAA,eACAC,MAAA,eACAC,GAAA,cACA,CAEA,CAEAE,eAAAC,CAAA,EAIA,OAFA,KAAAf,WAAA,CAAAe,EAEA,KAIAC,iBAAAC,CAAA,EAIA,OAFA,KAAAhB,aAAA,CAAAgB,EAEA,KAIAC,eAAAd,CAAA,EAIA,OAFA,KAAAA,WAAA,CAAAA,EAEA,KAIAe,KAAAC,CAAA,CAAAC,CAAA,CAAAC,CAAA,CAAAC,CAAA,EAEA,IAAAC,EAAA,IAAqB5B,EAAA6B,UAAU,MAAA1B,OAAA,EAE/ByB,EAAAE,OAAA,MAAAX,IAAA,EACAS,EAAAG,eAAA,gBACAH,EAAAI,gBAAA,MAAAC,aAAA,EACAL,EAAAM,kBAAA,MAAAC,eAAA,EAEAP,EAAAL,IAAA,CAAAC,EAAA,IAEA,KAAAY,KAAA,CAAAC,EAAAZ,EAAAE,EAEA,EAAGD,EAAAC,EAEH,CAEAS,MAAAC,CAAA,CAAAZ,CAAA,CAAAE,CAAA,EAEA,KAAAW,eAAA,CAAAD,EAAAZ,EAAA,UAAoDzB,EAAAuC,cAAc,EAAAC,KAAA,CAAAb,EAElE,CAEAW,gBAAAD,CAAA,CAAAI,CAAA,CAAAC,CAAA,CAAAC,CAAA,CAAAC,EAAqF5C,EAAA6C,oBAAoB,EAEzG,IAAAC,EAAA,CACAJ,aAAAA,GAAA,KAAA9B,mBAAA,CACA+B,eAAAA,GAAA,KAAA1B,qBAAA,CACA8B,aAAA,EAAAL,EACAE,iBAAAA,CACA,EAEA,YAAAI,cAAA,CAAAX,EAAAS,GAAAG,IAAA,CAAAR,EAEA,CAEAO,eAAAX,CAAA,CAAAS,CAAA,MAiCAI,EA/BA,IAAAC,EAAAC,KAAAC,SAAA,CAAAP,GAIA,GAAAjD,EAAAyD,GAAA,CAAAjB,GAAA,CAEA,IAAAkB,EAAA1D,EAAA2D,GAAA,CAAAnB,GAEA,GAAAkB,EAAAE,GAAA,GAAAN,EAEA,OAAAI,EAAAG,OAAA,CAEK,GAAArB,IAAAA,EAAAsB,UAAA,CAML,YAEA,gHAGA,CAIA,IAKAC,EAAA,KAAAlD,gBAAA,GACAmD,EAAAxB,EAAAsB,UAAA,CAIAG,EAAA,KAAAC,UAAA,CAAAH,EAAAC,GACAZ,IAAA,KAEAC,EAAAc,EAEA,IAAAC,QAAA,CAAAC,EAAAC,IAAA,CAEAjB,EAAAkB,UAAA,CAAAR,EAAA,EAAqCM,QAAAA,EAAAC,OAAAA,CAAA,EAErCjB,EAAAmB,WAAA,EAA2BC,KAAA,SAAAC,GAAAX,EAAAd,WAAAA,EAAAT,OAAAA,CAAA,EAAgD,CAAAA,EAAA,CAI3E,KAGAY,IAAA,SAAAuB,eAAA,CAAAC,EAAAC,QAAA,GA0BA,OAtBAZ,EACAtB,KAAA,SACAS,IAAA,MAEAC,GAAAU,GAEA,KAAAe,YAAA,CAAAzB,EAAAU,EAMA,GAGA/D,EAAA+E,GAAA,CAAAvC,EAAA,CAEAoB,IAAAN,EACAO,QAAAI,CAEA,GAEAA,CAEA,CAEAU,gBAAAK,CAAA,EAEA,IAAAH,EAAA,IAAuB1E,EAAA8E,cAAc,CAErCD,EAAAE,KAAA,EAEAL,EAAAM,QAAA,KAA0BhF,EAAAiF,eAAe,CAAAJ,EAAAE,KAAA,CAAAG,KAAA,KAIzC,QAAAC,EAAA,EAAmBA,EAAAN,EAAAO,UAAA,CAAAC,MAAA,CAAoCF,IAAA,CAEvD,IAAAG,EAAAT,EAAAO,UAAA,CAAAD,EAAA,CACAI,EAAAD,EAAAC,IAAA,CACAL,EAAAI,EAAAJ,KAAA,CACAM,EAAAF,EAAAE,QAAA,CAEAC,EAAA,IAAyBzF,EAAAiF,eAAe,CAAAC,EAAAM,GAExC,UAAAD,GAEA,KAAAG,uBAAA,CAAAD,EAAAH,EAAA1C,gBAAA,EAIA8B,EAAAiB,YAAA,CAAAJ,EAAAE,EAEA,CAEA,OAAAf,CAEA,CAEAgB,wBAAAD,CAAA,CAAAG,CAAA,EAOA,GAAAA,IAA2B5F,EAAAuC,cAAc,QAEzC,IAAAsD,EAAA,IAAqB7F,EAAA8F,KAAK,CAE1B,QAAAX,EAAA,EAAAY,EAAAN,EAAAO,KAAA,CAAyCb,EAAAY,EAAQZ,IAEjDU,EAAAI,mBAAA,CAAAR,EAAAN,GAAAe,mBAAA,GACAT,EAAAU,MAAA,CAAAhB,EAAAU,EAAAO,CAAA,CAAAP,EAAAQ,CAAA,CAAAR,EAAAS,CAAA,CAIA,CAEAC,aAAA/E,CAAA,CAAAgF,CAAA,EAEA,IAAA5E,EAAA,IAAqB5B,EAAA6B,UAAU,MAAA1B,OAAA,EAK/B,OAJAyB,EAAAE,OAAA,MAAA1B,WAAA,EACAwB,EAAAG,eAAA,CAAAyE,GACA5E,EAAAM,kBAAA,MAAAC,eAAA,EAEA,IAAA8B,QAAA,CAAAC,EAAAC,IAAA,CAEAvC,EAAAL,IAAA,CAAAC,EAAA0C,EAAAuC,KAAAA,EAAAtC,EAEA,EAEA,CAEAuC,SAAA,CAIA,OAFA,KAAAC,YAAA,GAEA,KAIAA,cAAA,CAEA,QAAApG,cAAA,aAAAA,cAAA,CAEA,IAAAqG,EAAA,iBAAAC,aAAA,YAAAxG,aAAA,CAAAiE,IAAA,CACAwC,EAAA,GAsCA,OApCAF,EAEAE,EAAAC,IAAA,MAAAR,YAAA,8BAIAO,EAAAC,IAAA,MAAAR,YAAA,kCACAO,EAAAC,IAAA,MAAAR,YAAA,uCAIA,KAAAhG,cAAA,CAAA0D,QAAA+C,GAAA,CAAAF,GACA7D,IAAA,KAEA,IAAAgE,EAAAC,CAAA,IAEAN,GAEA,MAAAvG,aAAA,CAAA8G,UAAA,CAAAD,CAAA,KAIA,IAAAE,EAAAC,EAAAC,QAAA,GAEAC,EAAA,CACA,sBACAN,EACA,GACA,eACAG,EAAAI,SAAA,CAAAJ,EAAAK,OAAA,MAAiC,EAAAL,EAAAM,WAAA,OACjC,CAAAC,IAAA,MAEA,MAAAhH,eAAA,CAAAiH,IAAAC,eAAA,KAAAC,KAAA,CAAAP,EAAA,EAEA,GAEA,KAAAhH,cAAA,CAIAwD,WAAAH,CAAA,CAAAC,CAAA,EAEA,YAAA8C,YAAA,GAAA1D,IAAA,MAEA,QAAAxC,UAAA,CAAA4E,MAAA,MAAA7E,WAAA,EAEA,IAAA0C,EAAA,IAAA6E,OAAA,KAAApH,eAAA,CAEAuC,CAAAA,EAAAkB,UAAA,IACAlB,EAAA8E,UAAA,IACA9E,EAAA+E,SAAA,GAEA/E,EAAAmB,WAAA,EAA0BC,KAAA,OAAAjE,cAAA,KAAAA,aAAA,GAE1B6C,EAAAgF,SAAA,UAAAC,CAAA,EAEA,IAAA1D,EAAA0D,EAAAC,IAAA,CAEA,OAAA3D,EAAAH,IAAA,EAEA,aACApB,EAAAkB,UAAA,CAAAK,EAAAF,EAAA,EAAAL,OAAA,CAAAO,GACA,UAEA,QACAvB,EAAAkB,UAAA,CAAAK,EAAAF,EAAA,EAAAJ,MAAA,CAAAM,GACA,cAGA4D,QAAAC,KAAA,4CAAA7D,EAAAH,IAAA,KAEA,CAEA,EAEA,KAAA7D,UAAA,CAAAsG,IAAA,CAAA7D,EAEA,MAEA,KAAAzC,UAAA,CAAA8H,IAAA,UAAAC,CAAA,CAAAlC,CAAA,EAEA,OAAAkC,EAAAP,SAAA,CAAA3B,EAAA2B,SAAA,OAIA,CAEA,IAAA/E,EAAA,KAAAzC,UAAA,MAAAA,UAAA,CAAA4E,MAAA,IAGA,OAFAnC,EAAA8E,UAAA,CAAApE,EAAA,CAAAC,EACAX,EAAA+E,SAAA,EAAApE,EACAX,CAEA,EAEA,CAEAyB,aAAAzB,CAAA,CAAAU,CAAA,EAEAV,EAAA+E,SAAA,EAAA/E,EAAA8E,UAAA,CAAApE,EAAA,CACA,OAAAV,EAAAkB,UAAA,CAAAR,EAAA,CACA,OAAAV,EAAA8E,UAAA,CAAApE,EAAA,CAIA6E,OAAA,CAEAJ,QAAAK,GAAA,oBAAAjI,UAAA,CAAAkI,GAAA,IAAAzF,EAAA+E,SAAA,EAEA,CAEAW,SAAA,CAEA,QAAAzD,EAAA,EAAmBA,EAAA,KAAA1E,UAAA,CAAA4E,MAAA,CAA4B,EAAAF,EAE/C,KAAA1E,UAAA,CAAA0E,EAAA,CAAA0D,SAAA,GAYA,OARA,KAAApI,UAAA,CAAA4E,MAAA,GAEA,UAAA1E,eAAA,EAEAiH,IAAAkB,eAAA,MAAAnI,eAAA,EAIA,KAIA,CAIA,SAAA0G,GAAA,CAEA,IAAAhH,EACAE,EAEA2H,UAAA,SAAAC,CAAA,EAEA,IAAA1D,EAAA0D,EAAAC,IAAA,CAEA,OAAA3D,EAAAH,IAAA,EAEA,WACAjE,EAAAoE,EAAApE,aAAA,CACAE,EAAA,IAAA0D,QAAA,SAAAC,CAAA,EAEA7D,EAAA0I,cAAA,UAAAC,CAAA,EAGA9E,EAAA,CAAiB8E,MAAAA,CAAA,EAEjB,EAEAC,mBAAA5I,EAEA,GACA,UAEA,SACA,IAAAgC,EAAAoC,EAAApC,MAAA,CACAS,EAAA2B,EAAA3B,UAAA,CACAvC,EAAA0C,IAAA,KAEA,IAAA+F,EAAAE,EAAAF,KAAA,CACAG,EAAA,IAAAH,EAAAI,OAAA,CAEA,IAEA,IAAA1E,EAAA1B,SA2BAgG,CAAA,CAAAG,CAAA,CAAAjE,CAAA,CAAApC,CAAA,MAKAuG,EACAC,EAJA,IAAA5G,EAAAI,EAAAJ,YAAA,CACAC,EAAAG,EAAAH,cAAA,CAKA4G,EAAAJ,EAAAK,sBAAA,CAAAtE,GAEA,GAAAqE,IAAAP,EAAAS,eAAA,CAEAJ,EAAA,IAAAL,EAAAU,IAAA,CACAJ,EAAAH,EAAAQ,iBAAA,CAAAzE,EAAAA,EAAAvB,UAAA,CAAA0F,QAEI,GAAAE,IAAAP,EAAAY,WAAA,CAEJP,EAAA,IAAAL,EAAAa,UAAA,CACAP,EAAAH,EAAAW,uBAAA,CAAA5E,EAAAA,EAAAvB,UAAA,CAAA0F,QAIA,4DAIA,IAAAC,EAAAS,EAAA,IAAAV,IAAAA,EAAAW,GAAA,CAEA,mDAAAV,EAAAW,SAAA,IAIA,IAAAvF,EAAA,CAAqBK,MAAA,KAAAK,WAAA,IAGrB,QAAA8E,KAAAxH,EAAA,KAIA+C,EACA0E,EAHA,IAAAC,EAAAC,IAAA,CAAA1H,CAAA,CAAAuH,EAAA,EASA,GAAApH,EAAAC,YAAA,CAEAoH,EAAAzH,CAAA,CAAAwH,EAAA,CACAzE,EAAA0D,EAAAmB,sBAAA,CAAAjB,EAAAc,OAEK,CAIL,GAAAA,KAFAA,CAAAA,EAAAhB,EAAAoB,cAAA,CAAAlB,EAAAL,CAAA,CAAAtG,CAAA,CAAAwH,EAAA,IAEA,SAEAzE,EAAA0D,EAAAqB,YAAA,CAAAnB,EAAAc,EAEA,KAEAM,EAAAC,SAwCA1B,CAAA,CAAAG,CAAA,CAAAE,CAAA,CAAAa,CAAA,CAAAE,CAAA,CAAA3E,CAAA,EAEA,IAAAkF,EAAAlF,EAAAmF,cAAA,GACAC,EAAAxB,EAAAyB,UAAA,GACAC,EAAAF,EAAAF,EACAhH,EAAAoH,EAAAX,EAAAY,iBAAA,CACAC,EAAAC,SAeAlC,CAAA,CAAAoB,CAAA,EAEA,OAAAA,GAEA,KAAAe,aAAA,OAAAnC,EAAAoC,UAAA,MACAC,UAAA,OAAArC,EAAAsC,OAAA,MACAC,WAAA,OAAAvC,EAAAwC,QAAA,MACAC,WAAA,OAAAzC,EAAA0C,QAAA,MACAC,WAAA,OAAA3C,EAAA4C,QAAA,MACAC,YAAA,OAAA7C,EAAA8C,SAAA,MACAC,YAAA,OAAA/C,EAAAgD,SAAA,CAIA,EA7BAhD,EAAAoB,GAEAJ,EAAAhB,EAAAiD,OAAA,CAAAtI,GACAwF,EAAA+C,iCAAA,CAAA7C,EAAA5D,EAAAwF,EAAAtH,EAAAqG,GACA,IAAA9E,EAAA,IAAAkF,EAAApB,EAAAmD,OAAA,CAAA9J,MAAA,CAAA2H,EAAAe,GAAAqB,KAAA,GAGA,OAFApD,EAAAqD,KAAA,CAAArC,GAEA,CACAzE,KAAA2E,EACAhF,MAAAA,EACAM,SAAAmF,CACA,CAEA,EA3DA3B,EAAAG,EAAAE,EAAAa,EAAAE,EAAA3E,GAEA,UAAAyE,GAEAO,CAAAA,EAAA7H,gBAAA,CAAAE,EAAAF,gBAAA,EAIA8B,EAAAU,UAAA,CAAA2B,IAAA,CAAA0D,EAEA,CAWA,OARAlB,IAAAP,EAAAS,eAAA,EAEA/E,CAAAA,EAAAK,KAAA,CAAAuH,SAUAtD,CAAA,CAAAG,CAAA,CAAAE,CAAA,EAEA,IAAAkD,EAAAlD,EAAAmD,SAAA,GACAC,EAAAF,EAAAA,EACA5I,EAAA8I,EAAAA,EAEAzC,EAAAhB,EAAAiD,OAAA,CAAAtI,GACAwF,EAAAuD,uBAAA,CAAArD,EAAA1F,EAAAqG,GACA,IAAAjF,EAAA,IAAAgH,YAAA/C,EAAAmD,OAAA,CAAA9J,MAAA,CAAA2H,EAAAyC,GAAAL,KAAA,GAGA,OAFApD,EAAAqD,KAAA,CAAArC,GAEA,CAAW9E,MAAAH,EAAAS,SAAA,EAEX,EAvBAwD,EAAAG,EAAAE,EAAA,EAIAL,EAAA2D,OAAA,CAAAtD,GAEA3E,CAEA,EA/GAsE,EAAAG,EAAA,IAAAkC,UAAAhJ,GAAAS,GAEA8J,EAAAlI,EAAAU,UAAA,CAAAuD,GAAA,IAAAkE,EAAA3H,KAAA,CAAA7C,MAAA,CAEAqC,CAAAA,EAAAK,KAAA,EAAA6H,EAAA7F,IAAA,CAAArC,EAAAK,KAAA,CAAAG,KAAA,CAAA7C,MAAA,EAEAgI,KAAAhG,WAAA,EAA0BC,KAAA,SAAAC,GAAAE,EAAAF,EAAA,CAAAG,SAAAA,CAAA,EAA0CkI,EAEpE,CAAO,MAAAtE,EAAA,CAEPD,QAAAC,KAAA,CAAAA,GAEA+B,KAAAhG,WAAA,EAA0BC,KAAA,QAAAC,GAAAE,EAAAF,EAAA,CAAA+D,MAAAA,EAAA7D,OAAA,EAE1B,QAAO,CAEPuE,EAAA2D,OAAA,CAAAxD,EAEA,CAEA,EAGA,CAEA,CA4IA,sEC8HA,SAAA2D,EAAApI,CAAA,CAAAqI,CAAA,EAEA,GAAAA,IAAmBC,EAAAC,iBAAiB,CAGpC,OADA5E,QAAA6E,IAAA,4FACAxI,CAEA,CAEA,GAAAqI,IAAmBC,EAAAG,mBAAmB,EAAAJ,IAAiBC,EAAAI,qBAAqB,CA0F5E,OADA/E,QAAAC,KAAA,uEAAAyE,GACArI,CAEA,EA1FA,IAAAK,EAAAL,EAAA2I,QAAA,GAIA,GAAAtI,IAAA,GAAAA,EAAA,CAEA,IAAAuI,EAAA,GAEAzM,EAAA6D,EAAA6I,YAAA,aAEA,GAAA1M,KAAA4F,IAAA5F,EAcA,OADAwH,QAAAC,KAAA,4GACA5D,CAEA,CAdA,QAAAS,EAAA,EAAqBA,EAAAtE,EAAAmF,KAAA,CAAoBb,IAEzCmI,EAAAvG,IAAA,CAAA5B,GAIAT,EAAAM,QAAA,CAAAsI,GACAvI,EAAAL,EAAA2I,QAAA,EASA,KAIAG,EAAAzI,EAAAiB,KAAA,GACAyH,EAAA,GAEA,GAAAV,IAAoBC,EAAAG,mBAAmB,CAIvC,QAAAhI,EAAA,EAAoBA,GAAAqI,EAAwBrI,IAE5CsI,EAAA1G,IAAA,CAAAhC,EAAA2I,IAAA,KACAD,EAAA1G,IAAA,CAAAhC,EAAA2I,IAAA,CAAAvI,IACAsI,EAAA1G,IAAA,CAAAhC,EAAA2I,IAAA,CAAAvI,EAAA,SAQA,QAAAA,EAAA,EAAoBA,EAAAqI,EAAuBrI,IAE3CA,EAAA,MAEAsI,EAAA1G,IAAA,CAAAhC,EAAA2I,IAAA,CAAAvI,IACAsI,EAAA1G,IAAA,CAAAhC,EAAA2I,IAAA,CAAAvI,EAAA,IACAsI,EAAA1G,IAAA,CAAAhC,EAAA2I,IAAA,CAAAvI,EAAA,MAIAsI,EAAA1G,IAAA,CAAAhC,EAAA2I,IAAA,CAAAvI,EAAA,IACAsI,EAAA1G,IAAA,CAAAhC,EAAA2I,IAAA,CAAAvI,EAAA,IACAsI,EAAA1G,IAAA,CAAAhC,EAAA2I,IAAA,CAAAvI,IAMA,CAEAsI,EAAApI,MAAA,KAAAmI,GAEAnF,QAAAC,KAAA,qGAMA,IAAAqF,EAAAjJ,EAAAkJ,KAAA,GAIA,OAHAD,EAAA3I,QAAA,CAAAyI,GACAE,EAAAE,WAAA,GAEAF,CAEA,CAOA,CClwBA,MAAAG,UAAyBd,EAAA/M,MAAM,CAE/BC,YAAAC,CAAA,EAEA,MAAAA,GAEA,KAAA4N,WAAA,MACA,KAAAC,UAAA,MACA,KAAAC,cAAA,MAEA,KAAAC,eAAA,IAEA,KAAAC,QAAA,UAAAC,CAAA,EAEA,WAAAC,EAAAD,EAEA,GAEA,KAAAD,QAAA,UAAAC,CAAA,EAEA,WAAAE,EAAAF,EAEA,GAEA,KAAAD,QAAA,UAAAC,CAAA,EAEA,WAAAG,EAAAH,EAEA,GAEA,KAAAD,QAAA,UAAAC,CAAA,EAEA,WAAAI,EAAAJ,EAEA,GAEA,KAAAD,QAAA,UAAAC,CAAA,EAEA,WAAAK,EAAAL,EAEA,GAEA,KAAAD,QAAA,UAAAC,CAAA,EAEA,WAAAM,EAAAN,EAEA,GAEA,KAAAD,QAAA,UAAAC,CAAA,EAEA,WAAAO,EAAAP,EAEA,GAEA,KAAAD,QAAA,UAAAC,CAAA,EAEA,WAAAQ,EAAAR,EAEA,GAEA,KAAAD,QAAA,UAAAC,CAAA,EAEA,WAAAS,EAAAT,EAEA,GAEA,KAAAD,QAAA,UAAAC,CAAA,EAEA,WAAAU,EAAAV,EAEA,GAEA,KAAAD,QAAA,UAAAC,CAAA,EAEA,WAAAW,EAAAX,EAEA,GAEA,KAAAD,QAAA,UAAAC,CAAA,EAEA,WAAAY,EAAAZ,EAEA,GAEA,KAAAD,QAAA,UAAAC,CAAA,EAEA,WAAAa,EAAAb,EAEA,GAEA,KAAAD,QAAA,UAAAC,CAAA,EAEA,WAAAc,EAAAd,EAEA,EAEA,CAEA7M,KAAAC,CAAA,CAAAC,CAAA,CAAAC,CAAA,CAAAC,CAAA,MAIAwN,EAFA,IAAAC,EAAA,KAMAD,EAFA,UAAAA,YAAA,CAEA,KAAAA,YAAA,CAEI,UAAAhO,IAAA,CAEJ,KAAAA,IAAA,CAIkB6L,EAAAqC,WAAA,CAAAC,cAA0B,CAAA9N,GAO5C,KAAArB,OAAA,CAAAoP,SAAA,CAAA/N,GAEA,IAAAgO,EAAA,SAAArH,CAAA,EAEAxG,EAEAA,EAAAwG,GAIAE,QAAAC,KAAA,CAAAH,GAIAiH,EAAAjP,OAAA,CAAAsP,SAAA,CAAAjO,GACA4N,EAAAjP,OAAA,CAAAuP,OAAA,CAAAlO,EAEA,EAEAI,EAAA,IAAqBoL,EAAAnL,UAAU,MAAA1B,OAAA,EAE/ByB,EAAAE,OAAA,MAAAX,IAAA,EACAS,EAAAG,eAAA,gBACAH,EAAAI,gBAAA,MAAAC,aAAA,EACAL,EAAAM,kBAAA,MAAAC,eAAA,EAEAP,EAAAL,IAAA,CAAAC,EAAA,SAAA4G,CAAA,EAEA,IAEAgH,EAAAhN,KAAA,CAAAgG,EAAA+G,EAAA,SAAAQ,CAAA,EAEAlO,EAAAkO,GAEAP,EAAAjP,OAAA,CAAAuP,OAAA,CAAAlO,EAEA,EAAKgO,EAEL,CAAK,MAAArH,EAAA,CAELqH,EAAArH,EAEA,CAEA,EAAGzG,EAAA8N,EAEH,CAEAI,eAAA7B,CAAA,EAGA,OADA,KAAAA,WAAA,CAAAA,EACA,KAIA8B,cAAA,CAEA,YAEA,mGAEA,CAIAC,cAAA9B,CAAA,EAGA,OADA,KAAAA,UAAA,CAAAA,EACA,KAIA+B,kBAAA9B,CAAA,EAGA,OADA,KAAAA,cAAA,CAAAA,EACA,KAIAE,SAAA1L,CAAA,EAQA,OANA,UAAAyL,eAAA,CAAAzG,OAAA,CAAAhF,IAEA,KAAAyL,eAAA,CAAAnH,IAAA,CAAAtE,GAIA,KAIAuN,WAAAvN,CAAA,EAQA,OANA,UAAAyL,eAAA,CAAAzG,OAAA,CAAAhF,IAEA,KAAAyL,eAAA,CAAA+B,MAAA,MAAA/B,eAAA,CAAAzG,OAAA,CAAAhF,GAAA,GAIA,KAIAL,MAAAgG,CAAA,CAAAjH,CAAA,CAAAM,CAAA,CAAAE,CAAA,MAEAuO,EACA,IAAAC,EAAA,GACAC,EAAA,GACAC,EAAA,IAAAC,YAEA,oBAAAlI,EAEA8H,EAAA9M,KAAAhB,KAAA,CAAAgG,QAEI,GAAAA,aAAAmI,YAAA,CAEJ,IAAAC,EAAAH,EAAAI,MAAA,KAAA9E,WAAAvD,EAAA,MAEA,GAAAoI,IAAAE,EAAA,CAEA,IAEAP,CAAA,CAAAQ,EAAAC,eAAA,MAAAC,EAAAzI,EAEA,CAAM,MAAAE,EAAA,CAEN3G,GAAAA,EAAA2G,GACA,MAEA,CAEA4H,EAAA9M,KAAAhB,KAAA,CAAA+N,CAAA,CAAAQ,EAAAC,eAAA,EAAAE,OAAA,CAEA,MAEAZ,EAAA9M,KAAAhB,KAAA,CAAAiO,EAAAI,MAAA,CAAArI,GAEA,MAIA8H,EAAA9H,CAEA,CAEA,GAAA8H,KAAAzJ,IAAAyJ,EAAAa,KAAA,EAAAb,EAAAa,KAAA,CAAAC,OAAA,OAEArP,GAAAA,EAAA,kFACA,MAEA,KAEAyM,EAAA,IAAA6C,EAAAf,EAAA,CAEA/O,KAAAA,GAAA,KAAAgO,YAAA,KACA+B,YAAA,KAAAA,WAAA,CACAjP,cAAA,KAAAA,aAAA,CACA9B,QAAA,KAAAA,OAAA,CACA6N,WAAA,KAAAA,UAAA,CACAC,eAAA,KAAAA,cAAA,GAIAG,EAAA+C,UAAA,CAAAnP,gBAAA,MAAAC,aAAA,EAEA,QAAAkD,EAAA,EAAmBA,EAAA,KAAA+I,eAAA,CAAA7I,MAAA,CAAiCF,IAAA,CAEpD,IAAAiM,EAAA,KAAAlD,eAAA,CAAA/I,EAAA,CAAAiJ,EACAgC,CAAAA,CAAA,CAAAgB,EAAA7L,IAAA,EAAA6L,EAMAjB,CAAA,CAAAiB,EAAA7L,IAAA,IAEA,CAEA,GAAA2K,EAAAmB,cAAA,CAEA,QAAAlM,EAAA,EAAoBA,EAAA+K,EAAAmB,cAAA,CAAAhM,MAAA,CAAgC,EAAAF,EAAA,CAEpD,IAAAmM,EAAApB,EAAAmB,cAAA,CAAAlM,EAAA,CACAoM,EAAArB,EAAAqB,kBAAA,KAEA,OAAAD,GAEA,KAAAX,EAAAa,mBAAA,CACArB,CAAA,CAAAmB,EAAA,KAAAG,EACA,WAEAd,EAAAe,0BAAA,CACAvB,CAAA,CAAAmB,EAAA,KAAAK,EAAAzB,EAAA,KAAAnC,WAAA,EACA,WAEA4C,EAAAiB,qBAAA,CACAzB,CAAA,CAAAmB,EAAA,KAAAO,EACA,WAEAlB,EAAAmB,qBAAA,CACA3B,CAAA,CAAAmB,EAAA,KAAAS,EACA,cAIAR,EAAA9J,OAAA,CAAA6J,IAAA,GAAAlB,KAAA3J,IAAA2J,CAAA,CAAAkB,EAAA,EAEAjJ,QAAA6E,IAAA,yCAAAoE,EAAA,KAIA,CAEA,CAEA,EAEAU,aAAA,CAAA7B,GACA/B,EAAA6D,UAAA,CAAA7B,GACAhC,EAAAhM,KAAA,CAAAX,EAAAE,EAEA,CAEAuQ,WAAA9J,CAAA,CAAAjH,CAAA,EAEA,IAAAiO,EAAA,KAEA,WAAAnL,QAAA,SAAAC,CAAA,CAAAC,CAAA,EAEAiL,EAAAhN,KAAA,CAAAgG,EAAAjH,EAAA+C,EAAAC,EAEA,EAEA,CAEA,CAIA,SAAAgO,GAAA,CAEA,IAAAC,EAAA,GAEA,OAEA5O,IAAA,SAAAC,CAAA,EAEA,OAAA2O,CAAA,CAAA3O,EAAA,EAIA4O,IAAA,SAAA5O,CAAA,CAAA6O,CAAA,EAEAF,CAAA,CAAA3O,EAAA,CAAA6O,CAEA,EAEAC,OAAA,SAAA9O,CAAA,EAEA,OAAA2O,CAAA,CAAA3O,EAAA,EAIA+O,UAAA,WAEAJ,EAAA,EAEA,CAEA,CAEA,CAMA,IAAAzB,EAAA,CACAC,gBAAA,kBACAc,2BAAA,6BACAe,oBAAA,sBACAC,wBAAA,0BACAC,kBAAA,oBACAC,oBAAA,sBACAC,uBAAA,yBACAC,2BAAA,6BACAC,0BAAA,4BACAvB,oBAAA,sBACAwB,qBAAA,uBACAC,mBAAA,qBACArB,sBAAA,wBACAE,sBAAA,wBACAoB,gCAAA,kCACAC,iBAAA,mBACAC,iBAAA,mBACAC,wBAAA,0BACAC,wBAAA,yBACA,CAOA,OAAAtE,EAEA9O,YAAAkO,CAAA,EAEA,KAAAA,MAAA,CAAAA,EACA,KAAA7I,IAAA,CAAAoL,EAAA8B,mBAAA,CAGA,KAAAc,KAAA,EAAiBC,KAAA,GAAQC,KAAA,GAEzB,CAEAC,WAAA,CAEA,IAAAtF,EAAA,KAAAA,MAAA,CACAuF,EAAA,KAAAvF,MAAA,CAAA8B,IAAA,CAAA0D,KAAA,KAEA,QAAAC,EAAA,EAAAC,EAAAH,EAAAtO,MAAA,CAAyDwO,EAAAC,EAAwBD,IAAA,CAEjF,IAAAE,EAAAJ,CAAA,CAAAE,EAAA,CAEAE,EAAA5D,UAAA,EACA4D,EAAA5D,UAAA,MAAA5K,IAAA,GACAwO,KAAAtN,IAAAsN,EAAA5D,UAAA,MAAA5K,IAAA,EAAAyO,KAAA,EAEA5F,EAAA6F,WAAA,MAAAV,KAAA,CAAAQ,EAAA5D,UAAA,MAAA5K,IAAA,EAAAyO,KAAA,CAIA,CAEA,CAEAE,WAAAC,CAAA,MAYAC,EAVA,IAAAhG,EAAA,KAAAA,MAAA,CACAiG,EAAA,SAAAF,EACAG,EAAAlG,EAAAmF,KAAA,CAAA/P,GAAA,CAAA6Q,GAEA,GAAAC,EAAA,OAAAA,CAAA,CAEA,IAAApE,EAAA9B,EAAA8B,IAAA,CACAC,EAAA,EAAAA,UAAA,EAAAD,EAAAC,UAAA,MAAA5K,IAAA,MACAgP,EAAApE,EAAAqE,MAAA,KACAC,EAAAF,CAAA,CAAAJ,EAAA,CAGApT,EAAA,IAAoBiM,EAAAlH,KAAK,UAEzBW,MAAAA,IAAAgO,EAAA1T,KAAA,EAAAA,EAAA2T,SAAA,CAAAD,EAAA1T,KAAA,EAEA,IAAA4T,EAAAF,KAAAhO,IAAAgO,EAAAE,KAAA,CAAAF,EAAAE,KAAA,GAEA,OAAAF,EAAAnQ,IAAA,EAEA,kBAEA8P,CADAA,EAAA,IAAoBpH,EAAA4H,gBAAgB,CAAA7T,EAAA,EACpC8T,MAAA,CAAAhU,QAAA,CAAA+D,GAAA,SACAwP,EAAA/B,GAAA,CAAA+B,EAAAS,MAAA,EACA,UAEA,QAEAT,CADAA,EAAA,IAAoBpH,EAAA8H,UAAU,CAAA/T,EAAA,EAC9BgU,QAAA,CAAAJ,EACA,UAEA,OAEAP,CADAA,EAAA,IAAoBpH,EAAAgI,SAAS,CAAAjU,EAAA,EAC7BgU,QAAA,CAAAJ,EAEAF,EAAAQ,IAAA,CAAAR,EAAAQ,IAAA,KACAR,EAAAQ,IAAA,CAAAC,cAAA,CAAAT,KAAAhO,IAAAgO,EAAAQ,IAAA,CAAAC,cAAA,CAAAT,EAAAQ,IAAA,CAAAC,cAAA,GACAT,EAAAQ,IAAA,CAAAE,cAAA,CAAAV,KAAAhO,IAAAgO,EAAAQ,IAAA,CAAAE,cAAA,CAAAV,EAAAQ,IAAA,CAAAE,cAAA,CAAAC,KAAAC,EAAA,GACAjB,EAAAkB,KAAA,CAAAb,EAAAQ,IAAA,CAAAE,cAAA,CACAf,EAAAmB,QAAA,GAAAd,EAAAQ,IAAA,CAAAC,cAAA,CAAAT,EAAAQ,IAAA,CAAAE,cAAA,CACAf,EAAAS,MAAA,CAAAhU,QAAA,CAAA+D,GAAA,SACAwP,EAAA/B,GAAA,CAAA+B,EAAAS,MAAA,EACA,cAGA,wDAAAJ,EAAAnQ,IAAA,EAoBA,OAdA8P,EAAAvT,QAAA,CAAA+D,GAAA,QAEAwP,EAAAoB,KAAA,GAEAC,EAAArB,EAAAK,GAEAhO,KAAAA,IAAAgO,EAAAiB,SAAA,EAAAtB,CAAAA,EAAAsB,SAAA,CAAAjB,EAAAiB,SAAA,EAEAtB,EAAA7O,IAAA,CAAA6I,EAAAuH,gBAAA,CAAAlB,EAAAlP,IAAA,WAAA4O,GAEAG,EAAArQ,QAAAC,OAAA,CAAAkQ,GAEAhG,EAAAmF,KAAA,CAAAlB,GAAA,CAAAgC,EAAAC,GAEAA,CAEA,CAEAsB,cAAAtR,CAAA,CAAAS,CAAA,EAEA,GAAAT,UAAAA,EAEA,YAAA4P,UAAA,CAAAnP,EAFA,CAMA8Q,qBAAAhC,CAAA,EAEA,IAAAxJ,EAAA,KACA+D,EAAA,KAAAA,MAAA,CACA8B,EAAA9B,EAAA8B,IAAA,CACA6D,EAAA7D,EAAA0D,KAAA,CAAAC,EAAA,CACAY,EAAA,EAAAtE,UAAA,EAAA4D,EAAA5D,UAAA,MAAA5K,IAAA,MACA4O,EAAAM,EAAAT,KAAA,QAEA,KAAAvN,IAAA0N,EAAA,KAEA,KAAAD,UAAA,CAAAC,GAAAlR,IAAA,UAAA+Q,CAAA,EAEA,OAAA5F,EAAA0H,WAAA,CAAAzL,EAAAkJ,KAAA,CAAAY,EAAAH,EAEA,EANA,CAUA,CAOA,MAAAvC,EAEAvR,aAAA,CAEA,KAAAqF,IAAA,CAAAoL,EAAAa,mBAAA,CAIAuE,iBAAA,CAEA,OAAS/I,EAAAgJ,iBAAiB,CAI1BC,aAAAC,CAAA,CAAAC,CAAA,CAAA/H,CAAA,EAEA,IAAAgI,EAAA,GAEAF,EAAAnV,KAAA,KAA6BiM,EAAAlH,KAAK,QAClCoQ,EAAAG,OAAA,GAEA,IAAAC,EAAAH,EAAAI,oBAAA,CAEA,GAAAD,EAAA,CAEA,GAAAE,MAAAC,OAAA,CAAAH,EAAAI,eAAA,GAEA,IAAAxR,EAAAoR,EAAAI,eAAA,CAEAR,EAAAnV,KAAA,CAAA2T,SAAA,CAAAxP,GACAgR,EAAAG,OAAA,CAAAnR,CAAA,IAEA,KAEAuB,IAAA6P,EAAAK,gBAAA,EAEAP,EAAArP,IAAA,CAAAqH,EAAAwI,aAAA,CAAAV,EAAA,MAAAI,EAAAK,gBAAA,CAAmG3J,EAAA6J,YAAY,EAI/G,QAEA5S,QAAA+C,GAAA,CAAAoP,EAEA,CAEA,CAOA,MAAAvH,EAEA3O,YAAAkO,CAAA,EAEA,KAAAA,MAAA,CAAAA,EACA,KAAA7I,IAAA,CAAAoL,EAAAuC,+BAAA,CAIA4D,qBAAAC,CAAA,CAAAb,CAAA,EAEA,IAAA9H,EAAA,KAAAA,MAAA,CACA+H,EAAA/H,EAAA8B,IAAA,CAAA8G,SAAA,CAAAD,EAAA,CAEA,IAAAZ,EAAAhG,UAAA,GAAAgG,EAAAhG,UAAA,MAAA5K,IAAA,EAEA,OAAAtB,QAAAC,OAAA,EAEA,CAEA,IAAA+S,EAAAd,EAAAhG,UAAA,MAAA5K,IAAA,EAAA0R,gBAAA,CAQA,OANAxQ,KAAAA,IAAAwQ,GAEAf,CAAAA,EAAAgB,iBAAA,CAAAD,CAAA,EAIAhT,QAAAC,OAAA,EAEA,CAEA,CAOA,MAAAmK,EAEAnO,YAAAkO,CAAA,EAEA,KAAAA,MAAA,CAAAA,EACA,KAAA7I,IAAA,CAAAoL,EAAA+B,uBAAA,CAIAqD,gBAAAgB,CAAA,EAEA,IAAA3I,EAAA,KAAAA,MAAA,CACA+H,EAAA/H,EAAA8B,IAAA,CAAA8G,SAAA,CAAAD,EAAA,QAEA,EAAA5G,UAAA,EAAAgG,EAAAhG,UAAA,MAAA5K,IAAA,EAESyH,EAAAmK,oBAAoB,CAF7B,KAMAL,qBAAAC,CAAA,CAAAb,CAAA,EAEA,IAAA9H,EAAA,KAAAA,MAAA,CACA+H,EAAA/H,EAAA8B,IAAA,CAAA8G,SAAA,CAAAD,EAAA,CAEA,IAAAZ,EAAAhG,UAAA,GAAAgG,EAAAhG,UAAA,MAAA5K,IAAA,EAEA,OAAAtB,QAAAC,OAAA,EAEA,CAEA,IAAAkS,EAAA,GAEAgB,EAAAjB,EAAAhG,UAAA,MAAA5K,IAAA,EA0BA,GAxBAkB,KAAAA,IAAA2Q,EAAAC,eAAA,EAEAnB,CAAAA,EAAAoB,SAAA,CAAAF,EAAAC,eAAA,EAIA5Q,KAAAA,IAAA2Q,EAAAG,gBAAA,EAEAnB,EAAArP,IAAA,CAAAqH,EAAAwI,aAAA,CAAAV,EAAA,eAAAkB,EAAAG,gBAAA,GAIA9Q,KAAAA,IAAA2Q,EAAAI,wBAAA,EAEAtB,CAAAA,EAAAuB,kBAAA,CAAAL,EAAAI,wBAAA,EAIA/Q,KAAAA,IAAA2Q,EAAAM,yBAAA,EAEAtB,EAAArP,IAAA,CAAAqH,EAAAwI,aAAA,CAAAV,EAAA,wBAAAkB,EAAAM,yBAAA,GAIAN,KAAA3Q,IAAA2Q,EAAAO,sBAAA,GAEAvB,EAAArP,IAAA,CAAAqH,EAAAwI,aAAA,CAAAV,EAAA,qBAAAkB,EAAAO,sBAAA,GAEAP,KAAA3Q,IAAA2Q,EAAAO,sBAAA,CAAAC,KAAA,GAEA,IAAAA,EAAAR,EAAAO,sBAAA,CAAAC,KAAA,CAEA1B,EAAA2B,oBAAA,KAA8C7K,EAAA8K,OAAO,CAAAF,EAAAA,EAErD,CAEA,OAEA3T,QAAA+C,GAAA,CAAAoP,EAEA,CAEA,CAOA,MAAArH,EAEA7O,YAAAkO,CAAA,EAEA,KAAAA,MAAA,CAAAA,EACA,KAAA7I,IAAA,CAAAoL,EAAAoC,yBAAA,CAIAgD,gBAAAgB,CAAA,EAEA,IAAA3I,EAAA,KAAAA,MAAA,CACA+H,EAAA/H,EAAA8B,IAAA,CAAA8G,SAAA,CAAAD,EAAA,QAEA,EAAA5G,UAAA,EAAAgG,EAAAhG,UAAA,MAAA5K,IAAA,EAESyH,EAAAmK,oBAAoB,CAF7B,KAMAL,qBAAAC,CAAA,CAAAb,CAAA,EAEA,IAAA9H,EAAA,KAAAA,MAAA,CACA+H,EAAA/H,EAAA8B,IAAA,CAAA8G,SAAA,CAAAD,EAAA,CAEA,IAAAZ,EAAAhG,UAAA,GAAAgG,EAAAhG,UAAA,MAAA5K,IAAA,EAEA,OAAAtB,QAAAC,OAAA,EAEA,CAEA,IAAAkS,EAAA,GAEAgB,EAAAjB,EAAAhG,UAAA,MAAA5K,IAAA,EA4CA,OA1CAkB,KAAAA,IAAA2Q,EAAAW,iBAAA,EAEA7B,CAAAA,EAAA8B,WAAA,CAAAZ,EAAAW,iBAAA,EAIAtR,KAAAA,IAAA2Q,EAAAa,kBAAA,EAEA7B,EAAArP,IAAA,CAAAqH,EAAAwI,aAAA,CAAAV,EAAA,iBAAAkB,EAAAa,kBAAA,GAIAxR,KAAAA,IAAA2Q,EAAAc,cAAA,EAEAhC,CAAAA,EAAAiC,cAAA,CAAAf,EAAAc,cAAA,EAIAzR,KAAAA,IAAAyP,EAAAkC,yBAAA,EAEAlC,CAAAA,EAAAkC,yBAAA,YAIA3R,KAAAA,IAAA2Q,EAAAiB,2BAAA,EAEAnC,CAAAA,EAAAkC,yBAAA,IAAAhB,EAAAiB,2BAAA,EAIA5R,KAAAA,IAAA2Q,EAAAkB,2BAAA,EAEApC,CAAAA,EAAAkC,yBAAA,IAAAhB,EAAAkB,2BAAA,EAIA7R,KAAAA,IAAA2Q,EAAAmB,2BAAA,EAEAnC,EAAArP,IAAA,CAAAqH,EAAAwI,aAAA,CAAAV,EAAA,0BAAAkB,EAAAmB,2BAAA,GAIAtU,QAAA+C,GAAA,CAAAoP,EAEA,CAEA,CAOA,MAAA3H,EAEAvO,YAAAkO,CAAA,EAEA,KAAAA,MAAA,CAAAA,EACA,KAAA7I,IAAA,CAAAoL,EAAAiC,mBAAA,CAIAmD,gBAAAgB,CAAA,EAEA,IAAA3I,EAAA,KAAAA,MAAA,CACA+H,EAAA/H,EAAA8B,IAAA,CAAA8G,SAAA,CAAAD,EAAA,QAEA,EAAA5G,UAAA,EAAAgG,EAAAhG,UAAA,MAAA5K,IAAA,EAESyH,EAAAmK,oBAAoB,CAF7B,KAMAL,qBAAAC,CAAA,CAAAb,CAAA,EAEA,IAAA9H,EAAA,KAAAA,MAAA,CACA+H,EAAA/H,EAAA8B,IAAA,CAAA8G,SAAA,CAAAD,EAAA,CAEA,IAAAZ,EAAAhG,UAAA,GAAAgG,EAAAhG,UAAA,MAAA5K,IAAA,EAEA,OAAAtB,QAAAC,OAAA,EAEA,CAEA,IAAAkS,EAAA,GAEAF,EAAAsC,UAAA,KAAkCxL,EAAAlH,KAAK,QACvCoQ,EAAAuC,cAAA,GACAvC,EAAAwC,KAAA,GAEA,IAAAtB,EAAAjB,EAAAhG,UAAA,MAAA5K,IAAA,EA0BA,OAxBAkB,KAAAA,IAAA2Q,EAAAuB,gBAAA,EAEAzC,EAAAsC,UAAA,CAAA9D,SAAA,CAAA0C,EAAAuB,gBAAA,EAIAlS,KAAAA,IAAA2Q,EAAAwB,oBAAA,EAEA1C,CAAAA,EAAAuC,cAAA,CAAArB,EAAAwB,oBAAA,EAIAnS,KAAAA,IAAA2Q,EAAAyB,iBAAA,EAEAzC,EAAArP,IAAA,CAAAqH,EAAAwI,aAAA,CAAAV,EAAA,gBAAAkB,EAAAyB,iBAAA,CAAqG7L,EAAA6J,YAAY,GAIjHpQ,KAAAA,IAAA2Q,EAAA0B,qBAAA,EAEA1C,EAAArP,IAAA,CAAAqH,EAAAwI,aAAA,CAAAV,EAAA,oBAAAkB,EAAA0B,qBAAA,GAIA7U,QAAA+C,GAAA,CAAAoP,EAEA,CAEA,CAQA,MAAA1H,EAEAxO,YAAAkO,CAAA,EAEA,KAAAA,MAAA,CAAAA,EACA,KAAA7I,IAAA,CAAAoL,EAAAmC,0BAAA,CAIAiD,gBAAAgB,CAAA,EAEA,IAAA3I,EAAA,KAAAA,MAAA,CACA+H,EAAA/H,EAAA8B,IAAA,CAAA8G,SAAA,CAAAD,EAAA,QAEA,EAAA5G,UAAA,EAAAgG,EAAAhG,UAAA,MAAA5K,IAAA,EAESyH,EAAAmK,oBAAoB,CAF7B,KAMAL,qBAAAC,CAAA,CAAAb,CAAA,EAEA,IAAA9H,EAAA,KAAAA,MAAA,CACA+H,EAAA/H,EAAA8B,IAAA,CAAA8G,SAAA,CAAAD,EAAA,CAEA,IAAAZ,EAAAhG,UAAA,GAAAgG,EAAAhG,UAAA,MAAA5K,IAAA,EAEA,OAAAtB,QAAAC,OAAA,EAEA,CAEA,IAAAkS,EAAA,GAEAgB,EAAAjB,EAAAhG,UAAA,MAAA5K,IAAA,EAcA,OAZAkB,KAAAA,IAAA2Q,EAAA2B,kBAAA,EAEA7C,CAAAA,EAAA8C,YAAA,CAAA5B,EAAA2B,kBAAA,EAIAtS,KAAAA,IAAA2Q,EAAA6B,mBAAA,EAEA7C,EAAArP,IAAA,CAAAqH,EAAAwI,aAAA,CAAAV,EAAA,kBAAAkB,EAAA6B,mBAAA,GAIAhV,QAAA+C,GAAA,CAAAoP,EAEA,CAEA,CAOA,MAAAzH,EAEAzO,YAAAkO,CAAA,EAEA,KAAAA,MAAA,CAAAA,EACA,KAAA7I,IAAA,CAAAoL,EAAAqC,oBAAA,CAIA+C,gBAAAgB,CAAA,EAEA,IAAA3I,EAAA,KAAAA,MAAA,CACA+H,EAAA/H,EAAA8B,IAAA,CAAA8G,SAAA,CAAAD,EAAA,QAEA,EAAA5G,UAAA,EAAAgG,EAAAhG,UAAA,MAAA5K,IAAA,EAESyH,EAAAmK,oBAAoB,CAF7B,KAMAL,qBAAAC,CAAA,CAAAb,CAAA,EAEA,IAAA9H,EAAA,KAAAA,MAAA,CACA+H,EAAA/H,EAAA8B,IAAA,CAAA8G,SAAA,CAAAD,EAAA,CAEA,IAAAZ,EAAAhG,UAAA,GAAAgG,EAAAhG,UAAA,MAAA5K,IAAA,EAEA,OAAAtB,QAAAC,OAAA,EAEA,CAEA,IAAAkS,EAAA,GAEAgB,EAAAjB,EAAAhG,UAAA,MAAA5K,IAAA,EAEA2Q,EAAAgD,SAAA,CAAA9B,KAAA3Q,IAAA2Q,EAAA+B,eAAA,CAAA/B,EAAA+B,eAAA,GAEA1S,KAAAA,IAAA2Q,EAAAgC,gBAAA,EAEAhD,EAAArP,IAAA,CAAAqH,EAAAwI,aAAA,CAAAV,EAAA,eAAAkB,EAAAgC,gBAAA,GAIAlD,EAAAmD,mBAAA,CAAAjC,EAAAiC,mBAAA,EAAAC,IAEA,IAAAC,EAAAnC,EAAAoC,gBAAA,UAGA,OAFAtD,EAAAsD,gBAAA,KAAwCxM,EAAAlH,KAAK,CAAAyT,CAAA,IAAAA,CAAA,IAAAA,CAAA,KAE7CtV,QAAA+C,GAAA,CAAAoP,EAEA,CAEA,CAOA,MAAAxH,EAEA1O,YAAAkO,CAAA,EAEA,KAAAA,MAAA,CAAAA,EACA,KAAA7I,IAAA,CAAAoL,EAAAgC,iBAAA,CAIAoD,gBAAAgB,CAAA,EAEA,IAAA3I,EAAA,KAAAA,MAAA,CACA+H,EAAA/H,EAAA8B,IAAA,CAAA8G,SAAA,CAAAD,EAAA,QAEA,EAAA5G,UAAA,EAAAgG,EAAAhG,UAAA,MAAA5K,IAAA,EAESyH,EAAAmK,oBAAoB,CAF7B,KAMAL,qBAAAC,CAAA,CAAAb,CAAA,EAEA,IAAA9H,EAAA,KAAAA,MAAA,CACA+H,EAAA/H,EAAA8B,IAAA,CAAA8G,SAAA,CAAAD,EAAA,CAEA,IAAAZ,EAAAhG,UAAA,GAAAgG,EAAAhG,UAAA,MAAA5K,IAAA,EAEA,OAAAtB,QAAAC,OAAA,EAEA,CAEA,IAAAkT,EAAAjB,EAAAhG,UAAA,MAAA5K,IAAA,EAIA,OAFA2Q,EAAAuD,GAAA,CAAArC,KAAA3Q,IAAA2Q,EAAAqC,GAAA,CAAArC,EAAAqC,GAAA,KAEAxV,QAAAC,OAAA,EAEA,CAEA,CAOA,MAAA4K,EAEA5O,YAAAkO,CAAA,EAEA,KAAAA,MAAA,CAAAA,EACA,KAAA7I,IAAA,CAAAoL,EAAAkC,sBAAA,CAIAkD,gBAAAgB,CAAA,EAEA,IAAA3I,EAAA,KAAAA,MAAA,CACA+H,EAAA/H,EAAA8B,IAAA,CAAA8G,SAAA,CAAAD,EAAA,QAEA,EAAA5G,UAAA,EAAAgG,EAAAhG,UAAA,MAAA5K,IAAA,EAESyH,EAAAmK,oBAAoB,CAF7B,KAMAL,qBAAAC,CAAA,CAAAb,CAAA,EAEA,IAAA9H,EAAA,KAAAA,MAAA,CACA+H,EAAA/H,EAAA8B,IAAA,CAAA8G,SAAA,CAAAD,EAAA,CAEA,IAAAZ,EAAAhG,UAAA,GAAAgG,EAAAhG,UAAA,MAAA5K,IAAA,EAEA,OAAAtB,QAAAC,OAAA,EAEA,CAEA,IAAAkS,EAAA,GAEAgB,EAAAjB,EAAAhG,UAAA,MAAA5K,IAAA,EAEA2Q,EAAAwD,iBAAA,CAAAtC,KAAA3Q,IAAA2Q,EAAAuC,cAAA,CAAAvC,EAAAuC,cAAA,GAEAlT,KAAAA,IAAA2Q,EAAAwC,eAAA,EAEAxD,EAAArP,IAAA,CAAAqH,EAAAwI,aAAA,CAAAV,EAAA,uBAAAkB,EAAAwC,eAAA,GAIA,IAAAL,EAAAnC,EAAAyC,mBAAA,UASA,OARA3D,EAAA4D,aAAA,KAAqC9M,EAAAlH,KAAK,CAAAyT,CAAA,IAAAA,CAAA,IAAAA,CAAA,KAE1C9S,KAAAA,IAAA2Q,EAAA2C,oBAAA,EAEA3D,EAAArP,IAAA,CAAAqH,EAAAwI,aAAA,CAAAV,EAAA,mBAAAkB,EAAA2C,oBAAA,CAA2G/M,EAAA6J,YAAY,GAIvH5S,QAAA+C,GAAA,CAAAoP,EAEA,CAEA,CAOA,MAAA9H,EAEApO,YAAAkO,CAAA,EAEA,KAAAA,MAAA,CAAAA,EACA,KAAA7I,IAAA,CAAAoL,EAAAsC,kBAAA,CAIA+G,YAAAC,CAAA,EAEA,IAAA7L,EAAA,KAAAA,MAAA,CACA8B,EAAA9B,EAAA8B,IAAA,CAEAgK,EAAAhK,EAAAiK,QAAA,CAAAF,EAAA,CAEA,IAAAC,EAAA/J,UAAA,GAAA+J,EAAA/J,UAAA,MAAA5K,IAAA,EAEA,YAIA,IAAA6R,EAAA8C,EAAA/J,UAAA,MAAA5K,IAAA,EACA3D,EAAAwM,EAAAgM,OAAA,CAAApM,UAAA,CAEA,IAAApM,EAAA,CAEA,IAAAsO,CAAAA,EAAAqB,kBAAA,EAAArB,EAAAqB,kBAAA,CAAA9J,OAAA,MAAAlC,IAAA,MAOA,kBALA,qFASA,OAEA6I,EAAAiM,gBAAA,CAAAJ,EAAA7C,EAAAkD,MAAA,CAAA1Y,EAEA,CAEA,CAOA,MAAA2M,EAEArO,YAAAkO,CAAA,EAEA,KAAAA,MAAA,CAAAA,EACA,KAAA7I,IAAA,CAAAoL,EAAAwC,gBAAA,CACA,KAAAoH,WAAA,MAIAP,YAAAC,CAAA,EAEA,IAAA1U,EAAA,KAAAA,IAAA,CACA6I,EAAA,KAAAA,MAAA,CACA8B,EAAA9B,EAAA8B,IAAA,CAEAgK,EAAAhK,EAAAiK,QAAA,CAAAF,EAAA,CAEA,IAAAC,EAAA/J,UAAA,GAAA+J,EAAA/J,UAAA,CAAA5K,EAAA,CAEA,YAIA,IAAA6R,EAAA8C,EAAA/J,UAAA,CAAA5K,EAAA,CACA+U,EAAApK,EAAAsK,MAAA,CAAApD,EAAAkD,MAAA,EAEA1Y,EAAAwM,EAAAqM,aAAA,CACA,GAAAH,EAAAI,GAAA,EAEA,IAAAC,EAAAvM,EAAAgM,OAAA,CAAAja,OAAA,CAAAya,UAAA,CAAAN,EAAAI,GAAA,EACA,OAAAC,GAAA/Y,CAAAA,EAAA+Y,CAAA,CAEA,QAEA,KAAAE,aAAA,GAAA5X,IAAA,UAAAsX,CAAA,EAEA,GAAAA,EAAA,OAAAnM,EAAAiM,gBAAA,CAAAJ,EAAA7C,EAAAkD,MAAA,CAAA1Y,EAAA,CAEA,GAAAsO,EAAAqB,kBAAA,EAAArB,EAAAqB,kBAAA,CAAA9J,OAAA,CAAAlC,IAAA,EAEA,yEAKA,OAAA6I,EAAA4L,WAAA,CAAAC,EAEA,EAEA,CAEAY,eAAA,CAsBA,OApBA,KAAAN,WAAA,EAEA,MAAAA,WAAA,KAAAtW,QAAA,SAAAC,CAAA,EAEA,IAAA4W,EAAA,IAAAC,KAIAD,CAAAA,EAAAE,GAAA,mFAEAF,EAAAG,MAAA,CAAAH,EAAAI,OAAA,YAEAhX,EAAA4W,IAAAA,EAAAK,MAAA,CAEA,CAEA,EAAK,EAIL,KAAAZ,WAAA,CAIA,CAOA,MAAA/L,EAEAtO,YAAAkO,CAAA,EAEA,KAAAA,MAAA,CAAAA,EACA,KAAA7I,IAAA,CAAAoL,EAAAyC,gBAAA,CACA,KAAAmH,WAAA,MAIAP,YAAAC,CAAA,EAEA,IAAA1U,EAAA,KAAAA,IAAA,CACA6I,EAAA,KAAAA,MAAA,CACA8B,EAAA9B,EAAA8B,IAAA,CAEAgK,EAAAhK,EAAAiK,QAAA,CAAAF,EAAA,CAEA,IAAAC,EAAA/J,UAAA,GAAA+J,EAAA/J,UAAA,CAAA5K,EAAA,CAEA,YAIA,IAAA6R,EAAA8C,EAAA/J,UAAA,CAAA5K,EAAA,CACA+U,EAAApK,EAAAsK,MAAA,CAAApD,EAAAkD,MAAA,EAEA1Y,EAAAwM,EAAAqM,aAAA,CACA,GAAAH,EAAAI,GAAA,EAEA,IAAAC,EAAAvM,EAAAgM,OAAA,CAAAja,OAAA,CAAAya,UAAA,CAAAN,EAAAI,GAAA,EACA,OAAAC,GAAA/Y,CAAAA,EAAA+Y,CAAA,CAEA,QAEA,KAAAE,aAAA,GAAA5X,IAAA,UAAAsX,CAAA,EAEA,GAAAA,EAAA,OAAAnM,EAAAiM,gBAAA,CAAAJ,EAAA7C,EAAAkD,MAAA,CAAA1Y,EAAA,CAEA,GAAAsO,EAAAqB,kBAAA,EAAArB,EAAAqB,kBAAA,CAAA9J,OAAA,CAAAlC,IAAA,EAEA,yEAKA,OAAA6I,EAAA4L,WAAA,CAAAC,EAEA,EAEA,CAEAY,eAAA,CAoBA,OAlBA,KAAAN,WAAA,EAEA,MAAAA,WAAA,KAAAtW,QAAA,SAAAC,CAAA,EAEA,IAAA4W,EAAA,IAAAC,KAGAD,CAAAA,EAAAE,GAAA,mbACAF,EAAAG,MAAA,CAAAH,EAAAI,OAAA,YAEAhX,EAAA4W,IAAAA,EAAAK,MAAA,CAEA,CAEA,EAAK,EAIL,KAAAZ,WAAA,CAIA,CAOA,MAAAtL,EAEA/O,YAAAkO,CAAA,EAEA,KAAA7I,IAAA,CAAAoL,EAAA0C,uBAAA,CACA,KAAAjF,MAAA,CAAAA,CAEA,CAEAgN,eAAArW,CAAA,EAEA,IAAAmL,EAAA,KAAA9B,MAAA,CAAA8B,IAAA,CACAmL,EAAAnL,EAAAoL,WAAA,CAAAvW,EAAA,CAEA,GAAAsW,CAAAA,EAAAlL,UAAA,GAAAkL,EAAAlL,UAAA,MAAA5K,IAAA,EAyDA,aAvDA,IAAAgW,EAAAF,EAAAlL,UAAA,MAAA5K,IAAA,EAEAlD,EAAA,KAAA+L,MAAA,CAAAwH,aAAA,UAAA2F,EAAAlZ,MAAA,EACA8G,EAAA,KAAAiF,MAAA,CAAAgM,OAAA,CAAAnM,cAAA,CAEA,IAAA9E,GAAA,CAAAA,EAAAqS,SAAA,EAEA,IAAAtL,CAAAA,EAAAqB,kBAAA,EAAArB,EAAAqB,kBAAA,CAAA9J,OAAA,MAAAlC,IAAA,MAOA,kBALA,4FASA,OAEAlD,EAAAY,IAAA,UAAAwY,CAAA,EAEA,IAAAC,EAAAH,EAAAG,UAAA,IACA/X,EAAA4X,EAAA5X,UAAA,IAEAqC,EAAAuV,EAAAvV,KAAA,CACA2V,EAAAJ,EAAAK,UAAA,CAEAtB,EAAA,IAAA3O,WAAA8P,EAAAC,EAAA/X,UAEA,EAAAkY,qBAAA,CAEA1S,EAAA0S,qBAAA,CAAA7V,EAAA2V,EAAArB,EAAAiB,EAAAO,IAAA,CAAAP,EAAAQ,MAAA,EAAA9Y,IAAA,UAAAwY,CAAA,EAEA,OAAAA,EAAApZ,MAAA,GAOA8G,EAAA6S,KAAA,CAAA/Y,IAAA,YAEA,IAAAqC,EAAA,IAAAiL,YAAAvK,EAAA2V,GAEA,OADAxS,EAAA8S,gBAAA,KAAAtQ,WAAArG,GAAAU,EAAA2V,EAAArB,EAAAiB,EAAAO,IAAA,CAAAP,EAAAQ,MAAA,EACAzW,CAEA,EAEA,EAIA,CAMA,CAEA,CAQA,MAAA4J,EAEAhP,YAAAkO,CAAA,EAEA,KAAA7I,IAAA,CAAAoL,EAAA2C,uBAAA,CACA,KAAAlF,MAAA,CAAAA,CAEA,CAEA8N,eAAArI,CAAA,EAEA,IAAA3D,EAAA,KAAA9B,MAAA,CAAA8B,IAAA,CACA6D,EAAA7D,EAAA0D,KAAA,CAAAC,EAAA,CAEA,IAAAE,EAAA5D,UAAA,GAAA4D,EAAA5D,UAAA,MAAA5K,IAAA,GACAwO,KAAAtN,IAAAsN,EAAAoI,IAAA,CAEA,YAIA,IAAAC,EAAAlM,EAAAmM,MAAA,CAAAtI,EAAAoI,IAAA,EAIA,QAAAG,KAAAF,EAAAG,UAAA,CAEA,GAAAD,EAAAR,IAAA,GAAAU,EAAAC,SAAA,EACAH,EAAAR,IAAA,GAAAU,EAAAE,cAAA,EACAJ,EAAAR,IAAA,GAAAU,EAAAG,YAAA,EACAL,KAAA7V,IAAA6V,EAAAR,IAAA,CAEA,YAMA,IAAAP,EAAAxH,EAAA5D,UAAA,MAAA5K,IAAA,EACAqX,EAAArB,EAAAnW,UAAA,CAIAgR,EAAA,GACAhR,EAAA,GAEA,QAAA3B,KAAAmZ,EAEAxG,EAAArP,IAAA,MAAAqH,MAAA,CAAAwH,aAAA,YAAAgH,CAAA,CAAAnZ,EAAA,EAAAR,IAAA,CAAA4Z,IAEAzX,CAAA,CAAA3B,EAAA,CAAAoZ,EACAzX,CAAA,CAAA3B,EAAA,WAMA,EAAA4B,MAAA,GAEA,MAIA+Q,EAAArP,IAAA,MAAAqH,MAAA,CAAA8N,cAAA,CAAArI,IAEA5P,QAAA+C,GAAA,CAAAoP,GAAAnT,IAAA,CAAA6Z,GAAA,CAEA,IAAAC,EAAAD,EAAAE,GAAA,GACAX,EAAAU,EAAAE,OAAA,CAAAF,EAAAG,QAAA,EAAAH,EAAA,CACA/W,EAAA8W,CAAA,IAAA9W,KAAA,CACAmX,EAAA,GAEA,QAAAhB,KAAAE,EAAA,CAGA,IAAAe,EAAA,IAAkBpQ,EAAAqQ,OAAO,CACzBC,EAAA,IAAkBtQ,EAAAuQ,OAAO,CACzBC,EAAA,IAAkBxQ,EAAAyQ,UAAU,CAC5BC,EAAA,IAAkB1Q,EAAAuQ,OAAO,QAEzBI,EAAA,IAA8B3Q,EAAA4Q,aAAa,CAAAzB,EAAAzX,QAAA,CAAAyX,EAAA0B,QAAA,CAAA7X,GAE3C,QAAAb,EAAA,EAAqBA,EAAAa,EAAWb,IAEhCC,EAAA0Y,WAAA,EAEAR,EAAArX,mBAAA,CAAAb,EAAA0Y,WAAA,CAAA3Y,GAIAC,EAAA2Y,QAAA,EAEAP,EAAAvX,mBAAA,CAAAb,EAAA2Y,QAAA,CAAA5Y,GAIAC,EAAA4Y,KAAA,EAEAN,EAAAzX,mBAAA,CAAAb,EAAA4Y,KAAA,CAAA7Y,GAIAwY,EAAAM,WAAA,CAAA9Y,EAAAiY,EAAAc,OAAA,CAAAZ,EAAAE,EAAAE,IAKA,QAAAxT,KAAA9E,EAEA,gBAAA8E,GACAA,aAAAA,GACAA,UAAAA,GAEAiS,EAAAzX,QAAA,CAAAiB,YAAA,CAAAuE,EAAA9E,CAAA,CAAA8E,EAAA,EAOI8C,EAAAmR,QAAA,CAAAC,SAAA,CAAAC,IAAA,CAAAC,IAA4B,CAAAX,EAAAxB,GAGhCwB,EAAAY,aAAA,IACA,KAAAnQ,MAAA,CAAAoQ,mBAAA,CAAAb,GAEAR,EAAApW,IAAA,CAAA4W,EAEA,QAEA,EAAAV,OAAA,EAEAF,EAAA0B,KAAA,GAEA1B,EAAA1K,GAAA,IAAA8K,GAEAJ,GAIAI,CAAA,MA/EA,CAqFA,CAGA,IAAAzM,EAAA,OAEAgO,EAAA,CAAuCtb,KAAA,WAAAub,IAAA,QAEvC,OAAA9N,EAEA3Q,YAAAkI,CAAA,EAEA,KAAA7C,IAAA,CAAAoL,EAAAC,eAAA,CACA,KAAAE,OAAA,MACA,KAAAvJ,IAAA,MAEA,IAAAqX,EAAA,IAAAC,SAAAzW,EAAA,EAXA,IAYAiI,EAAA,IAAAC,YAQA,GANA,KAAAwO,MAAA,EACAtO,MAAAH,EAAAI,MAAA,KAAA9E,WAAAvD,EAAAgE,KAAA,QACA4E,QAAA4N,EAAAG,SAAA,OACA1Z,OAAAuZ,EAAAG,SAAA,MACA,EAEA,KAAAD,MAAA,CAAAtO,KAAA,GAAAE,EAEA,iEAEI,QAAAoO,MAAA,CAAA9N,OAAA,GAEJ,8DAIA,IAAAgO,EAAA,KAAAF,MAAA,CAAAzZ,MAAA,CA9BA,GA+BA4Z,EAAA,IAAAJ,SAAAzW,EA/BA,IAgCA8W,EAAA,EAEA,KAAAA,EAAAF,GAAA,CAEA,IAAAG,EAAAF,EAAAF,SAAA,CAAAG,EAAA,IACAA,GAAA,EAEA,IAAAE,EAAAH,EAAAF,SAAA,CAAAG,EAAA,IAGA,GAFAA,GAAA,EAEAE,IAAAV,EAAAtb,IAAA,EAEA,IAAAic,EAAA,IAAA1T,WAAAvD,EAAAkX,GAAAJ,EAAAC,EACA,MAAArO,OAAA,CAAAT,EAAAI,MAAA,CAAA4O,EAEA,MAAK,GAAAD,IAAAV,EAAAC,GAAA,EAEL,IAAAjD,EAAA4D,GAAAJ,CACA,MAAA3X,IAAA,CAAAa,EAAAgE,KAAA,CAAAsP,EAAAA,EAAAyD,EAEA,IAIAA,CAEA,CAEA,eAAArO,OAAA,CAEA,yDAMA,CAOA,MAAAa,EAEAzR,YAAAgQ,CAAA,CAAAnC,CAAA,EAEA,IAAAA,EAEA,mEAIA,KAAAxI,IAAA,CAAAoL,EAAAe,0BAAA,CACA,KAAAxB,IAAA,CAAAA,EACA,KAAAnC,WAAA,CAAAA,EACA,KAAAA,WAAA,CAAArH,OAAA,EAEA,CAEA6Y,gBAAAjD,CAAA,CAAAlO,CAAA,EAEA,IAAA8B,EAAA,KAAAA,IAAA,CACAnC,EAAA,KAAAA,WAAA,CACAyR,EAAAlD,EAAAnM,UAAA,MAAA5K,IAAA,EAAA8V,UAAA,CACAoE,EAAAnD,EAAAnM,UAAA,MAAA5K,IAAA,EAAAH,UAAA,CACAsa,EAAA,GACAC,EAAA,GACAC,EAAA,GAEA,QAAA1V,KAAAuV,EAAA,CAEA,IAAAI,EAAAC,CAAA,CAAA5V,EAAA,EAAAA,EAAA6V,WAAA,EAEAL,CAAAA,CAAA,CAAAG,EAAA,CAAAJ,CAAA,CAAAvV,EAAA,CAIA,QAAAA,KAAAoS,EAAAlX,UAAA,EAEA,IAAAya,EAAAC,CAAA,CAAA5V,EAAA,EAAAA,EAAA6V,WAAA,GAEA,GAAAN,KAAAhZ,IAAAgZ,CAAA,CAAAvV,EAAA,EAEA,IAAA8V,EAAA9P,EAAA+P,SAAA,CAAA3D,EAAAlX,UAAA,CAAA8E,EAAA,EACAgW,EAAAC,CAAA,CAAAH,EAAAE,aAAA,EAEAN,CAAA,CAAAC,EAAA,CAAAK,EAAA3a,IAAA,CACAoa,CAAA,CAAAE,EAAA,CAAAG,CAAA,IAAAA,EAAAI,UAAA,CAEA,CAIA,OAAAhS,EAAAwH,aAAA,cAAA4J,GAAAvc,IAAA,UAAAoY,CAAA,EAEA,WAAApX,QAAA,SAAAC,CAAA,EAEA6J,EAAAzL,eAAA,CAAA+Y,EAAA,SAAA3W,CAAA,EAEA,QAAAwF,KAAAxF,EAAAU,UAAA,EAEA,IAAAK,EAAAf,EAAAU,UAAA,CAAA8E,EAAA,CACAkW,EAAAT,CAAA,CAAAzV,EAAA,MAEAzD,IAAA2Z,GAAA3a,CAAAA,EAAA2a,UAAA,CAAAA,CAAA,CAEA,CAEAlc,EAAAQ,EAEA,EAAKgb,EAAAE,EAEL,EAEA,EAEA,CAEA,CAOA,MAAA/N,EAEA3R,aAAA,CAEA,KAAAqF,IAAA,CAAAoL,EAAAiB,qBAAA,CAIAyO,cAAAC,CAAA,CAAAC,CAAA,SAEA9Z,KAAAA,IAAA8Z,EAAAC,QAAA,EAEAnY,QAAA6E,IAAA,8CAAA3H,IAAA,mCAIAkB,KAAAA,IAAA8Z,EAAAE,MAAA,EAAAF,KAAA9Z,IAAA8Z,EAAAG,QAAA,EAAAH,KAAA9Z,IAAA8Z,EAAA3I,KAAA,GAOA0I,EAAAA,EAAA1S,KAAA,GAEAnH,KAAAA,IAAA8Z,EAAAE,MAAA,EAEAH,EAAAG,MAAA,CAAA/L,SAAA,CAAA6L,EAAAE,MAAA,EAIAha,KAAAA,IAAA8Z,EAAAG,QAAA,EAEAJ,CAAAA,EAAAI,QAAA,CAAAH,EAAAG,QAAA,EAIAja,KAAAA,IAAA8Z,EAAA3I,KAAA,EAEA0I,EAAAK,MAAA,CAAAjM,SAAA,CAAA6L,EAAA3I,KAAA,EAIA0I,EAAAM,WAAA,KAxBAN,CA4BA,CAEA,CAOA,MAAAvO,EAEA7R,aAAA,CAEA,KAAAqF,IAAA,CAAAoL,EAAAmB,qBAAA,CAIA,CAQA,MAAA+O,UAAyC7T,EAAA8T,WAAW,CAEpD5gB,YAAA6gB,CAAA,CAAAC,CAAA,CAAAC,CAAA,CAAAC,CAAA,EAEA,MAAAH,EAAAC,EAAAC,EAAAC,EAEA,CAEAC,iBAAApc,CAAA,EAKA,IAAAO,EAAA,KAAA4b,YAAA,CACAE,EAAA,KAAAJ,YAAA,CACAK,EAAA,KAAAA,SAAA,CACAZ,EAAA1b,EAAAsc,EAAA,EAAAA,EAEA,QAAAlc,EAAA,EAAmBA,IAAAkc,EAAiBlc,IAEpCG,CAAA,CAAAH,EAAA,CAAAic,CAAA,CAAAX,EAAAtb,EAAA,CAIA,OAAAG,CAEA,CAEAgc,aAAAC,CAAA,CAAAC,CAAA,CAAAC,CAAA,CAAAC,CAAA,EAEA,IAAApc,EAAA,KAAA4b,YAAA,CACAE,EAAA,KAAAJ,YAAA,CACArF,EAAA,KAAA0F,SAAA,CAEAM,EAAAhG,EAAAA,EACAiG,EAAAjG,EAAAA,EAEAkG,EAAAH,EAAAF,EAEAlE,EAAA,CAAAmE,EAAAD,CAAA,EAAAK,EACAC,EAAAxE,EAAAA,EACAyE,EAAAD,EAAAxE,EAEA0E,EAAAT,EAAAK,EACAK,EAAAD,EAAAJ,EAEAM,EAAA,GAAAH,EAAA,EAAAD,EACAK,EAAAJ,EAAAD,EACAM,EAAA,EAAAF,EACAG,EAAAF,EAAAL,EAAAxE,EAIA,QAAAnY,EAAA,EAAmBA,IAAAwW,EAAcxW,IAAA,CAEjC,IAAAmd,EAAAlB,CAAA,CAAAa,EAAA9c,EAAAwW,EAAA,CACA4G,EAAAnB,CAAA,CAAAa,EAAA9c,EAAAwc,EAAA,CAAAE,EACAW,EAAApB,CAAA,CAAAY,EAAA7c,EAAAwW,EAAA,CACA8G,EAAArB,CAAA,CAAAY,EAAA7c,EAAA,CAAA0c,CAEAvc,CAAAA,CAAA,CAAAH,EAAA,CAAAid,EAAAE,EAAAD,EAAAE,EAAAL,EAAAM,EAAAL,EAAAM,CAEA,CAEA,OAAAnd,CAEA,CAEA,CAEA,IAAAod,EAAA,IAAe1V,EAAAyQ,UAAU,OAEzBkF,UAAA9B,EAEAS,aAAAC,CAAA,CAAAC,CAAA,CAAAC,CAAA,CAAAC,CAAA,EAEA,IAAApc,EAAA,MAAAgc,YAAA,CAAAC,EAAAC,EAAAC,EAAAC,GAIA,OAFAgB,EAAAhO,SAAA,CAAApP,GAAAsd,SAAA,GAAAC,OAAA,CAAAvd,GAEAA,CAEA,CAEA,CASA,IAAAkX,EAAA,CACAsG,MAAA,KAEAC,WAAA,MACAC,WAAA,MACAC,WAAA,MACAC,WAAA,MACAC,WAAA,MACAC,OAAA,KACAC,OAAA,MACAC,WAAA,MACAC,OAAA,EACAC,MAAA,EACAC,UAAA,EACAC,WAAA,EACAjH,UAAA,EACAC,eAAA,EACAC,aAAA,EACAgH,cAAA,KACAC,eAAA,IACA,EAEAzD,EAAA,CACA,KAAA9U,UACA,KAAAM,WACA,KAAAJ,WACA,KAAAM,YACA,KAAAE,YACA,KAAAZ,YACA,EAEA0Y,EAAA,CACA,KAAO7W,EAAA8W,aAAa,CACpB,KAAO9W,EAAA+W,YAAY,CACnB,KAAO/W,EAAAgX,0BAA0B,CACjC,KAAOhX,EAAAiX,yBAAyB,CAChC,KAAOjX,EAAAkX,yBAAyB,CAChC,KAAOlX,EAAAmX,wBAAwB,EAG/BC,EAAA,CACA,MAAQpX,EAAAqX,mBAAmB,CAC3B,MAAQrX,EAAAsX,sBAAsB,CAC9B,MAAQtX,EAAAuX,cAAc,EAGtBC,EAAA,CACA,SACA,OACA,OACA,OACA,OACA,OACA,OACA,EAEA1E,EAAA,CACA2E,SAAA,WACAC,OAAA,SACAC,QAAA,UACAC,WAAA,KACAC,WAAA,MACAC,QAAA,QACAC,UAAA,aACAC,SAAA,WACA,EAEAC,EAAA,CACArN,MAAA,QACAsN,YAAA,WACAxE,SAAA,aACAyE,QAAA,uBACA,EAEAC,EAAA,CACAC,YAAA5e,KAAAA,EAEA2c,OAASpW,EAAAsY,iBAAiB,CAC1BC,KAAOvY,EAAAwY,mBAAmB,EAG1BC,EAAA,CACAC,OAAA,SACAC,KAAA,OACAC,MAAA,OACA,EAyBA,SAAAC,EAAAC,CAAA,CAAAxT,CAAA,CAAAyT,CAAA,EAIA,QAAAxgB,KAAAwgB,EAAA5V,UAAA,CAEA1J,KAAAA,IAAAqf,CAAA,CAAAvgB,EAAA,GAEA+M,EAAA0T,QAAA,CAAAC,cAAA,CAAA3T,EAAA0T,QAAA,CAAAC,cAAA,KACA3T,EAAA0T,QAAA,CAAAC,cAAA,CAAA1gB,EAAA,CAAAwgB,EAAA5V,UAAA,CAAA5K,EAAA,CAMA,CAMA,SAAAkQ,EAAAnD,CAAA,CAAA4T,CAAA,EAEAzf,KAAAA,IAAAyf,EAAAC,MAAA,GAEA,iBAAAD,EAAAC,MAAA,CAEAC,OAAAC,MAAA,CAAA/T,EAAA0T,QAAA,CAAAE,EAAAC,MAAA,EAIA9d,QAAA6E,IAAA,uDAAAgZ,EAAAC,MAAA,EAMA,CA2JA,SAAAG,EAAAlhB,CAAA,EAEA,IAAAmhB,EAAA,GAEAC,EAAAJ,OAAAI,IAAA,CAAAphB,GAAAmD,IAAA,GAEA,QAAApD,EAAA,EAAAY,EAAAygB,EAAAnhB,MAAA,CAAoCF,EAAAY,EAAQZ,IAE5CohB,GAAAC,CAAA,CAAArhB,EAAA,KAAAC,CAAA,CAAAohB,CAAA,CAAArhB,EAAA,MAIA,OAAAohB,CAEA,CAEA,SAAAE,EAAAvmB,CAAA,EAKA,OAAAA,GAEA,KAAAmL,UACA,YAEA,MAAAM,WACA,YAEA,MAAAJ,WACA,cAEA,MAAAM,YACA,cAEA,SACA,iFAIA,CAWA,IAAA6a,EAAA,IAA4B1Z,EAAAqQ,OAAO,OAInCpM,EAEA/Q,YAAAgQ,EAAA,EAAuB,CAAAkK,EAAA,GAAe,CAEtC,KAAAlK,IAAA,CAAAA,EACA,KAAAC,UAAA,IACA,KAAAC,OAAA,IACA,KAAAgK,OAAA,CAAAA,EAGA,KAAA7G,KAAA,KAAApB,EAGA,KAAAwU,YAAA,KAAAC,IAGA,KAAAC,cAAA,IAGA,KAAAC,SAAA,IAGA,KAAAC,SAAA,EAAqBvT,KAAA,GAAQC,KAAA,IAC7B,KAAAuT,WAAA,EAAuBxT,KAAA,GAAQC,KAAA,IAC/B,KAAAwT,UAAA,EAAsBzT,KAAA,GAAQC,KAAA,IAE9B,KAAAyT,WAAA,IACA,KAAAC,YAAA,IAGA,KAAAC,aAAA,IAKA,IAAAC,EAAA,GACAC,EAAA,GACAC,EAAA,GAEA,oBAAAC,YAEAH,EAAA,sCAAAI,IAAA,CAAAD,UAAAE,SAAA,EAEAH,EAAAD,CADAA,EAAAE,UAAAE,SAAA,CAAAjgB,OAAA,gBACA+f,UAAAE,SAAA,CAAAC,KAAA,+BAIA,oBAAAC,mBAAAP,GAAAC,GAAAC,EAAA,GAEA,KAAA9M,aAAA,KAA4BzN,EAAA6a,aAAa,MAAAzN,OAAA,CAAAja,OAAA,EAIzC,KAAAsa,aAAA,KAA4BzN,EAAA8a,iBAAiB,MAAA1N,OAAA,CAAAja,OAAA,EAI7C,KAAAsa,aAAA,CAAAsN,cAAA,MAAA3N,OAAA,CAAAlJ,WAAA,EACA,KAAAuJ,aAAA,CAAAzY,gBAAA,MAAAoY,OAAA,CAAAnY,aAAA,EAEA,KAAAkP,UAAA,KAAwBnE,EAAAnL,UAAU,MAAAuY,OAAA,CAAAja,OAAA,EAClC,KAAAgR,UAAA,CAAApP,eAAA,gBAEA,yBAAAqY,OAAA,CAAAlJ,WAAA,EAEA,KAAAC,UAAA,CAAAjP,kBAAA,IAIA,CAEA8P,cAAA7B,CAAA,EAEA,KAAAA,UAAA,CAAAA,CAEA,CAEA8B,WAAA7B,CAAA,EAEA,KAAAA,OAAA,CAAAA,CAEA,CAEAhO,MAAAX,CAAA,CAAAE,CAAA,EAEA,IAAAyM,EAAA,KACA8B,EAAA,KAAAA,IAAA,CACAC,EAAA,KAAAA,UAAA,CAGA,KAAAoD,KAAA,CAAAf,SAAA,GACA,KAAAsU,SAAA,IAGA,KAAAkB,UAAA,UAAAC,CAAA,EAEA,OAAAA,EAAAvU,SAAA,EAAAuU,EAAAvU,SAAA,EAEA,GAEAzP,QAAA+C,GAAA,MAAAghB,UAAA,UAAAC,CAAA,EAEA,OAAAA,EAAAC,UAAA,EAAAD,EAAAC,UAAA,EAEA,IAAIjlB,IAAA,YAEJ,OAAAgB,QAAA+C,GAAA,EAEAoH,EAAA+Z,eAAA,UACA/Z,EAAA+Z,eAAA,cACA/Z,EAAA+Z,eAAA,WAEA,CAEA,GAAIllB,IAAA,UAAAmlB,CAAA,EAEJ,IAAA9iB,EAAA,CACA+iB,MAAAD,CAAA,IAAAlY,EAAAmY,KAAA,KACAC,OAAAF,CAAA,IACAG,WAAAH,CAAA,IACAI,QAAAJ,CAAA,IACArX,MAAAb,EAAAa,KAAA,CACA3C,OAAAA,EACA4X,SAAA,EACA,EAEAH,EAAA1V,EAAA7K,EAAA4K,GAEAuF,EAAAnQ,EAAA4K,GAEAjM,QAAA+C,GAAA,CAAAoH,EAAA4Z,UAAA,UAAAC,CAAA,EAEA,OAAAA,EAAAQ,SAAA,EAAAR,EAAAQ,SAAA,CAAAnjB,EAEA,IAAKrC,IAAA,YAELxB,EAAA6D,EAEA,EAEA,GAAI9C,KAAA,CAAAb,EAEJ,CAKA+R,WAAA,CAEA,IAAAC,EAAA,KAAAzD,IAAA,CAAA0D,KAAA,KACA8U,EAAA,KAAAxY,IAAA,CAAAyY,KAAA,KACAC,EAAA,KAAA1Y,IAAA,CAAAmM,MAAA,KAIA,QAAAwM,EAAA,EAAAC,EAAAJ,EAAArjB,MAAA,CAAyDwjB,EAAAC,EAAwBD,IAAA,CAEjF,IAAAE,EAAAL,CAAA,CAAAG,EAAA,CAAAE,MAAA,CAEA,QAAA5jB,EAAA,EAAAY,EAAAgjB,EAAA1jB,MAAA,CAAwCF,EAAAY,EAAQZ,IAEhDwO,CAAA,CAAAoV,CAAA,CAAA5jB,EAAA,EAAA6jB,MAAA,GAIA,CAIA,QAAAnV,EAAA,EAAAC,EAAAH,EAAAtO,MAAA,CAAyDwO,EAAAC,EAAwBD,IAAA,CAEjF,IAAAE,EAAAJ,CAAA,CAAAE,EAAA,MAEApN,IAAAsN,EAAAoI,IAAA,GAEA,KAAAlI,WAAA,MAAA8S,SAAA,CAAAhT,EAAAoI,IAAA,EAKA1V,KAAAA,IAAAsN,EAAAkV,IAAA,EAEAL,CAAAA,CAAA,CAAA7U,EAAAoI,IAAA,EAAA+M,aAAA,MAMAziB,KAAAA,IAAAsN,EAAAoV,MAAA,EAEA,KAAAlV,WAAA,MAAA+S,WAAA,CAAAjT,EAAAoV,MAAA,CAIA,CAEA,CAWAlV,YAAAV,CAAA,CAAAxO,CAAA,EAEA0B,KAAAA,IAAA1B,IAEA0B,KAAAA,IAAA8M,EAAAC,IAAA,CAAAzO,EAAA,EAEAwO,CAAAA,EAAAC,IAAA,CAAAzO,EAAA,CAAAwO,EAAAE,IAAA,CAAA1O,EAAA,IAIAwO,EAAAC,IAAA,CAAAzO,EAAA,GAEA,CAGA+Q,YAAAvC,CAAA,CAAAxO,CAAA,CAAAuN,CAAA,EAEA,GAAAiB,EAAAC,IAAA,CAAAzO,EAAA,WAAAuN,CAAA,CAEA,IAAA8W,EAAA9W,EAAA1E,KAAA,GAIAyb,EAAA,CAAAC,EAAA1b,IAAA,CAEA,IAAA2b,EAAA,KAAA5C,YAAA,CAAAnjB,GAAA,CAAA8lB,GAOA,QAAAnkB,EAAAqkB,EAAA,GANA,MAAAD,GAEA,KAAA5C,YAAA,CAAA/hB,GAAA,CAAAgJ,EAAA2b,GAIAD,EAAApM,QAAA,CAAAuM,OAAA,IAEAJ,EAAAG,EAAA5b,EAAAsP,QAAA,CAAA/X,EAAA,CAIA,EAMA,OAJAkkB,EAAA/W,EAAA8W,GAEAA,EAAA7jB,IAAA,eAAAgO,EAAAE,IAAA,CAAA1O,EAAA,GAEAqkB,CAEA,CAEAM,WAAAC,CAAA,EAEA,IAAAxZ,EAAAiW,OAAAhF,MAAA,MAAAhR,OAAA,EACAD,EAAApJ,IAAA,OAEA,QAAA5B,EAAA,EAAmBA,EAAAgL,EAAA9K,MAAA,CAAuBF,IAAA,CAE1C,IAAAG,EAAAqkB,EAAAxZ,CAAA,CAAAhL,EAAA,EAEA,GAAAG,EAAA,OAAAA,CAAA,CAIA,YAIA0iB,WAAA2B,CAAA,EAEA,IAAAxZ,EAAAiW,OAAAhF,MAAA,MAAAhR,OAAA,EACAD,EAAAyZ,OAAA,OAEA,IAAAxT,EAAA,GAEA,QAAAjR,EAAA,EAAmBA,EAAAgL,EAAA9K,MAAA,CAAuBF,IAAA,CAE1C,IAAAG,EAAAqkB,EAAAxZ,CAAA,CAAAhL,EAAA,EAEAG,GAAA8Q,EAAArP,IAAA,CAAAzB,EAEA,CAEA,OAAA8Q,CAEA,CAQAR,cAAAtR,CAAA,CAAAS,CAAA,EAEA,IAAAsP,EAAA/P,EAAA,IAAAS,EACAuP,EAAA,KAAAf,KAAA,CAAA/P,GAAA,CAAA6Q,GAEA,IAAAC,EAAA,CAEA,OAAAhQ,GAEA,YACAgQ,EAAA,KAAAuV,SAAA,CAAA9kB,GACA,UAEA,OACAuP,EAAA,KAAAoV,UAAA,UAAAzB,CAAA,EAEA,OAAAA,EAAA6B,QAAA,EAAA7B,EAAA6B,QAAA,CAAA/kB,EAEA,GACA,UAEA,OACAuP,EAAA,KAAAoV,UAAA,UAAAzB,CAAA,EAEA,OAAAA,EAAA8B,QAAA,EAAA9B,EAAA8B,QAAA,CAAAhlB,EAEA,GACA,UAEA,WACAuP,EAAA,KAAA0V,YAAA,CAAAjlB,GACA,UAEA,aACAuP,EAAA,KAAAoV,UAAA,UAAAzB,CAAA,EAEA,OAAAA,EAAA7M,cAAA,EAAA6M,EAAA7M,cAAA,CAAArW,EAEA,GACA,UAEA,SACAuP,EAAA,KAAA2V,UAAA,CAAAllB,GACA,UAEA,WACAuP,EAAA,KAAAoV,UAAA,UAAAzB,CAAA,EAEA,OAAAA,EAAAiC,YAAA,EAAAjC,EAAAiC,YAAA,CAAAnlB,EAEA,GACA,UAEA,UACAuP,EAAA,KAAAoV,UAAA,UAAAzB,CAAA,EAEA,OAAAA,EAAAjO,WAAA,EAAAiO,EAAAjO,WAAA,CAAAjV,EAEA,GACA,UAEA,OACAuP,EAAA,KAAA6V,QAAA,CAAAplB,GACA,UAEA,YACAuP,EAAA,KAAAoV,UAAA,UAAAzB,CAAA,EAEA,OAAAA,EAAAmC,aAAA,EAAAnC,EAAAmC,aAAA,CAAArlB,EAEA,GACA,UAEA,SACAuP,EAAA,KAAA+V,UAAA,CAAAtlB,GACA,cASA,IANAuP,CAAAA,EAAA,KAAAoV,UAAA,UAAAzB,CAAA,EAEA,OAAAA,GAAA,MAAAA,EAAArS,aAAA,EAAAqS,EAAArS,aAAA,CAAAtR,EAAAS,EAEA,EAAO,EAIP,6BAAAT,EAAA,CAQA,KAAAiP,KAAA,CAAAlB,GAAA,CAAAgC,EAAAC,EAEA,QAEAA,CAEA,CAOA6T,gBAAA7jB,CAAA,EAEA,IAAA8jB,EAAA,KAAA7U,KAAA,CAAA/P,GAAA,CAAAc,GAEA,IAAA8jB,EAAA,CAEA,IAAAha,EAAA,KACAkc,EAAA,KAAApa,IAAA,CAAA5L,EAAAA,CAAAA,SAAAA,EAAA,eAEA8jB,EAAAnkB,QAAA+C,GAAA,CAAAsjB,EAAA3hB,GAAA,UAAA4hB,CAAA,CAAAxlB,CAAA,EAEA,OAAAqJ,EAAAwH,aAAA,CAAAtR,EAAAS,EAEA,IAEA,KAAAwO,KAAA,CAAAlB,GAAA,CAAA/N,EAAA8jB,EAEA,QAEAA,CAEA,CAOA6B,WAAAO,CAAA,EAEA,IAAAC,EAAA,KAAAva,IAAA,CAAAtD,OAAA,CAAA4d,EAAA,CACA5oB,EAAA,KAAAuP,UAAA,CAEA,GAAAsZ,EAAAnmB,IAAA,EAAAmmB,gBAAAA,EAAAnmB,IAAA,CAEA,iCAAAmmB,EAAAnmB,IAAA,mCAKA,GAAAmmB,KAAAhkB,IAAAgkB,EAAA/P,GAAA,EAAA8P,IAAAA,EAEA,OAAAvmB,QAAAC,OAAA,MAAAiM,UAAA,CAAAQ,EAAAC,eAAA,EAAArJ,IAAA,CAEA,CAEA,IAAA6S,EAAA,KAAAA,OAAA,CAEA,WAAAnW,QAAA,SAAAC,CAAA,CAAAC,CAAA,EAEAvC,EAAAL,IAAA,CAAgByL,EAAAqC,WAAA,CAAAqb,UAAsB,CAAAD,EAAA/P,GAAA,CAAAN,EAAAjZ,IAAA,EAAA+C,EAAAuC,KAAAA,EAAA,WAEtCtC,EAAA,kDAAAsmB,EAAA/P,GAAA,OAEA,EAEA,EAEA,CAOAU,eAAAoE,CAAA,EAEA,IAAAmL,EAAA,KAAAza,IAAA,CAAAoL,WAAA,CAAAkE,EAAA,CAEA,YAAA5J,aAAA,UAAA+U,EAAAtoB,MAAA,EAAAY,IAAA,UAAAZ,CAAA,EAEA,IAAAsB,EAAAgnB,EAAAhnB,UAAA,IACA+X,EAAAiP,EAAAjP,UAAA,IACA,OAAArZ,EAAA+J,KAAA,CAAAsP,EAAAA,EAAA/X,EAEA,EAEA,CAOAqmB,aAAAY,CAAA,EAEA,IAAAxc,EAAA,KACA8B,EAAA,KAAAA,IAAA,CAEA8P,EAAA,KAAA9P,IAAA,CAAA+P,SAAA,CAAA2K,EAAA,CAEA,GAAA5K,KAAAvZ,IAAAuZ,EAAA3E,UAAA,EAAA2E,KAAAvZ,IAAAuZ,EAAA6K,MAAA,EAEA,IAAArlB,EAAAgf,CAAA,CAAAxE,EAAA1b,IAAA,EACAwmB,EAAA3K,CAAA,CAAAH,EAAAE,aAAA,EACAE,EAAAJ,CAAA,IAAAA,EAAAI,UAAA,CAEAlb,EAAA,IAAA4lB,EAAA9K,EAAAha,KAAA,CAAAR,GACA,OAAAvB,QAAAC,OAAA,KAA+B8I,EAAA/H,eAAe,CAAAC,EAAAM,EAAA4a,GAE9C,KAEA2K,EAAA,GAmBA,OAjBA/K,KAAAvZ,IAAAuZ,EAAA3E,UAAA,CAEA0P,EAAAhkB,IAAA,MAAA6O,aAAA,cAAAoK,EAAA3E,UAAA,GAIA0P,EAAAhkB,IAAA,OAIAN,KAAAA,IAAAuZ,EAAA6K,MAAA,GAEAE,EAAAhkB,IAAA,MAAA6O,aAAA,cAAAoK,EAAA6K,MAAA,CAAAvd,OAAA,CAAA+N,UAAA,GACA0P,EAAAhkB,IAAA,MAAA6O,aAAA,cAAAoK,EAAA6K,MAAA,CAAAzJ,MAAA,CAAA/F,UAAA,IAIApX,QAAA+C,GAAA,CAAA+jB,GAAA9nB,IAAA,UAAAqY,CAAA,MAaApW,EAAA8lB,EAXA,IAAA3P,EAAAC,CAAA,IAEA9V,EAAAgf,CAAA,CAAAxE,EAAA1b,IAAA,EACAwmB,EAAA3K,CAAA,CAAAH,EAAAE,aAAA,EAGA+K,EAAAH,EAAA9f,iBAAA,CAEA0Q,EAAAsE,EAAAtE,UAAA,IACAE,EAAAoE,KAAAvZ,IAAAuZ,EAAA3E,UAAA,CAAAnL,EAAAoL,WAAA,CAAA0E,EAAA3E,UAAA,EAAAO,UAAA,CAAAnV,KAAAA,CAAA,CACA2Z,EAAAJ,CAAA,IAAAA,EAAAI,UAAA,CAIA,GAAAxE,GAAAA,IAPAqP,EAAAzlB,EAOA,CAIA,IAAA0lB,EAAA9V,KAAA+V,KAAA,CAAAzP,EAAAE,GACAwP,EAAA,qBAAApL,EAAA3E,UAAA,KAAA2E,EAAAE,aAAA,KAAAgL,EAAA,IAAAlL,EAAAha,KAAA,CACAqlB,EAAAjd,EAAAmF,KAAA,CAAA/P,GAAA,CAAA4nB,GAEAC,IAEAnmB,EAAA,IAAA4lB,EAAAzP,EAAA6P,EAAAtP,EAAAoE,EAAAha,KAAA,CAAA4V,EAAAqP,GAGAI,EAAA,IAAcre,EAAAse,iBAAiB,CAAApmB,EAAA0W,EAAAqP,GAE/B7c,EAAAmF,KAAA,CAAAlB,GAAA,CAAA+Y,EAAAC,IAIAL,EAAA,IAA0Bhe,EAAAue,0BAA0B,CAAAF,EAAA7lB,EAAA,EAAAoW,EAAAqP,EAAA7K,EAEpD,MAIAlb,EAFAmW,IAAA,GAAAA,EAEA,IAAAyP,EAAA9K,EAAAha,KAAA,CAAAR,GAIA,IAAAslB,EAAAzP,EAAAK,EAAAsE,EAAAha,KAAA,CAAAR,GAIAwlB,EAAA,IAA0Bhe,EAAA/H,eAAe,CAAAC,EAAAM,EAAA4a,EAEzC,CAGA,GAAAJ,KAAAvZ,IAAAuZ,EAAA6K,MAAA,EAEA,IAAAW,EAAAhH,EAAAiH,MAAA,CACAC,EAAAvL,CAAA,CAAAH,EAAA6K,MAAA,CAAAvd,OAAA,CAAA4S,aAAA,EAEAyL,EAAA3L,EAAA6K,MAAA,CAAAvd,OAAA,CAAAoO,UAAA,IACAkQ,EAAA5L,EAAA6K,MAAA,CAAAzJ,MAAA,CAAA1F,UAAA,IAEAmQ,EAAA,IAAAH,EAAApQ,CAAA,IAAAqQ,EAAA3L,EAAA6K,MAAA,CAAA7kB,KAAA,CAAAwlB,GACAM,EAAA,IAAAhB,EAAAxP,CAAA,IAAAsQ,EAAA5L,EAAA6K,MAAA,CAAA7kB,KAAA,CAAAR,GAEA,OAAA6V,GAGA2P,CAAAA,EAAA,IAA2Bhe,EAAA/H,eAAe,CAAA+lB,EAAA9lB,KAAA,CAAAkH,KAAA,GAAA4e,EAAAxlB,QAAA,CAAAwlB,EAAA5K,UAAA,GAI1C,QAAAjb,EAAA,EAAAY,EAAA8lB,EAAAxmB,MAAA,CAAgDF,EAAAY,EAAQZ,IAAA,CAExD,IAAAJ,EAAA8mB,CAAA,CAAA1mB,EAAA,CAMA,GAJA6lB,EAAAe,IAAA,CAAAhnB,EAAA+mB,CAAA,CAAA3mB,EAAAK,EAAA,EACAA,GAAA,GAAAwlB,EAAAgB,IAAA,CAAAjnB,EAAA+mB,CAAA,CAAA3mB,EAAAK,EAAA,IACAA,GAAA,GAAAwlB,EAAAiB,IAAA,CAAAlnB,EAAA+mB,CAAA,CAAA3mB,EAAAK,EAAA,IACAA,GAAA,GAAAwlB,EAAAkB,IAAA,CAAAnnB,EAAA+mB,CAAA,CAAA3mB,EAAAK,EAAA,IACAA,GAAA,mFAIA,QAEAwlB,CAEA,EAEA,CAOAhR,YAAAC,CAAA,EAEA,IAAA/J,EAAA,KAAAA,IAAA,CACAkK,EAAA,KAAAA,OAAA,CACAF,EAAAhK,EAAAiK,QAAA,CAAAF,EAAA,CACAkS,EAAAjS,EAAAI,MAAA,CACA8R,EAAAlc,EAAAsK,MAAA,CAAA2R,EAAA,CAEAvqB,EAAA,KAAA6Y,aAAA,CAEA,GAAA2R,EAAA1R,GAAA,EAEA,IAAAC,EAAAP,EAAAja,OAAA,CAAAya,UAAA,CAAAwR,EAAA1R,GAAA,EACA,OAAAC,GAAA/Y,CAAAA,EAAA+Y,CAAA,CAEA,QAEA,KAAAN,gBAAA,CAAAJ,EAAAkS,EAAAvqB,EAEA,CAEAyY,iBAAAJ,CAAA,CAAAkS,CAAA,CAAAvqB,CAAA,EAEA,IAAAwM,EAAA,KACA8B,EAAA,KAAAA,IAAA,CAEAgK,EAAAhK,EAAAiK,QAAA,CAAAF,EAAA,CACAmS,EAAAlc,EAAAsK,MAAA,CAAA2R,EAAA,CAEA9X,EAAA,CAAA+X,EAAA1R,GAAA,EAAA0R,EAAA/Q,UAAA,MAAAnB,EAAAmS,OAAA,CAEA,QAAAlF,YAAA,CAAA9S,EAAA,CAGA,YAAA8S,YAAA,CAAA9S,EAAA,CAIA,IAAA3Q,EAAA,KAAA4oB,eAAA,CAAAH,EAAAvqB,GAAAqB,IAAA,UAAAqd,CAAA,EAEAA,EAAAiM,KAAA,IAEAjM,EAAA/a,IAAA,CAAA2U,EAAA3U,IAAA,EAAA6mB,EAAA7mB,IAAA,KAEA,IAAAinB,EAAAtc,EAAAsc,QAAA,KACAH,EAAAG,CAAA,CAAAtS,EAAAmS,OAAA,MASA,OAPA/L,EAAAmM,SAAA,CAAA5I,CAAA,CAAAwI,EAAAI,SAAA,GAA6Dzf,EAAA+W,YAAY,CACzEzD,EAAAoM,SAAA,CAAA7I,CAAA,CAAAwI,EAAAK,SAAA,GAA6D1f,EAAAmX,wBAAwB,CACrF7D,EAAAqM,KAAA,CAAAvI,CAAA,CAAAiI,EAAAM,KAAA,GAAuD3f,EAAAuX,cAAc,CACrEjE,EAAAsM,KAAA,CAAAxI,CAAA,CAAAiI,EAAAO,KAAA,GAAuD5f,EAAAuX,cAAc,CAErEnW,EAAAuY,YAAA,CAAA/hB,GAAA,CAAA0b,EAAA,CAAuCnG,SAAAF,CAAA,GAEvCqG,CAEA,GAAI9d,KAAA,YAEJ,cAMA,OAFA,KAAA2kB,YAAA,CAAA9S,EAAA,CAAA3Q,EAEAA,CAEA,CAEA4oB,gBAAAH,CAAA,CAAAvqB,CAAA,EAGA,IAAAsO,EAAA,KAAAA,IAAA,CACAkK,EAAA,KAAAA,OAAA,CAEA,QAAA3T,IAAA,KAAAygB,WAAA,CAAAiF,EAAA,CAEA,YAAAjF,WAAA,CAAAiF,EAAA,CAAAlpB,IAAA,IAAAqd,EAAA1S,KAAA,GAEA,CAEA,IAAAwe,EAAAlc,EAAAsK,MAAA,CAAA2R,EAAA,CAEAvkB,EAAAyC,KAAAzC,GAAA,EAAAyC,KAAAwiB,SAAA,CAEAC,EAAAV,EAAA1R,GAAA,KACAqS,EAAA,GAEA,GAAAX,KAAA3lB,IAAA2lB,EAAA/Q,UAAA,CAIAyR,EAAA1e,IArBA,CAqBAwH,aAAA,cAAAwW,EAAA/Q,UAAA,EAAApY,IAAA,UAAAoY,CAAA,EAEA0R,EAAA,GACA,IAAAC,EAAA,IAAAllB,KAAA,CAAAuT,EAAA,EAA6C/W,KAAA8nB,EAAAa,QAAA,GAE7C,OADAH,EAAAllB,EAAAC,eAAA,CAAAmlB,EAGA,QAEI,GAAAZ,KAAA3lB,IAAA2lB,EAAA1R,GAAA,CAEJ,uCAAAyR,EAAA,kCAIA,IAAAzoB,EAAAO,QAAAC,OAAA,CAAA4oB,GAAA7pB,IAAA,UAAA6pB,CAAA,EAEA,WAAA7oB,QAAA,SAAAC,CAAA,CAAAC,CAAA,EAEA,IAAA1C,EAAAyC,CAEA,MAAAtC,EAAAsrB,mBAAA,EAEAzrB,CAAAA,EAAA,SAAA0rB,CAAA,EAEA,IAAA7M,EAAA,IAA0BtT,EAAAogB,OAAO,CAAAD,EACjC7M,CAAAA,EAAAM,WAAA,IAEA1c,EAAAoc,EAEA,GAIA1e,EAAAL,IAAA,CAAiByL,EAAAqC,WAAA,CAAAqb,UAAsB,CAAAoC,EAAA1S,EAAAjZ,IAAA,EAAAM,EAAAgF,KAAAA,EAAAtC,EAEvC,EAEA,GAAIlB,IAAA,UAAAqd,CAAA,MA5vBJ5F,EAwwBA,MARA,KAAAqS,GAEAnlB,EAAAkB,eAAA,CAAAgkB,GAIAxM,EAAA0F,QAAA,CAAAiH,QAAA,CAAAb,EAAAa,QAAA,EApwBA,EAFAvS,EAswBA0R,EAAA1R,GAAA,EApwBA2S,MAAA,sBAAA3S,IAAAA,EAAA2S,MAAA,oCACA3S,EAAA2S,MAAA,qBAAA3S,IAAAA,EAAA2S,MAAA,oCAEA,WAHA,EAswBA/M,CAEA,GAAI9d,KAAA,UAAA8F,CAAA,EAGJ,MADAD,QAAAC,KAAA,2CAAAwkB,GACAxkB,CAAA,GAKA,OADA,KAAA4e,WAAA,CAAAiF,EAAA,CAAAzoB,EACAA,CAEA,CASAkT,cAAAV,CAAA,CAAAoX,CAAA,CAAAC,CAAA,CAAAC,CAAA,EAEA,IAAApf,EAAA,KAEA,YAAAwH,aAAA,WAAA2X,EAAAxoB,KAAA,EAAA9B,IAAA,UAAAqd,CAAA,EAEA,IAAAA,EAAA,YAUA,GANA7Z,KAAAA,IAAA8mB,EAAA/M,QAAA,EAAA+M,GAAAA,EAAA/M,QAAA,EAAA8M,UAAAA,GAAAC,GAAAA,EAAA/M,QAAA,EAEAnY,QAAA6E,IAAA,oCAAAqgB,EAAA/M,QAAA,iBAAA8M,EAAA,uBAIAlf,EAAA+B,UAAA,CAAAQ,EAAAiB,qBAAA,GAEA,IAAA2O,EAAAgN,KAAA9mB,IAAA8mB,EAAApd,UAAA,CAAAod,EAAApd,UAAA,CAAAQ,EAAAiB,qBAAA,EAAAnL,KAAAA,CAAA,CAEA,GAAA8Z,EAAA,CAEA,IAAAkN,EAAArf,EAAAuY,YAAA,CAAAnjB,GAAA,CAAA8c,GACAA,EAAAlS,EAAA+B,UAAA,CAAAQ,EAAAiB,qBAAA,EAAAyO,aAAA,CAAAC,EAAAC,GACAnS,EAAAuY,YAAA,CAAA/hB,GAAA,CAAA0b,EAAAmN,EAEA,EAEA,OAEAhnB,KAAAA,IAAA+mB,GAEAlN,CAAAA,EAAAkN,QAAA,CAAAA,CAAA,EAIAtX,CAAA,CAAAoX,EAAA,CAAAhN,EAEAA,CAEA,EAEA,CAUA9B,oBAAArC,CAAA,EAEA,IAAAzX,EAAAyX,EAAAzX,QAAA,CACAmZ,EAAA1B,EAAA0B,QAAA,CAEA6P,EAAAhpB,KAAA+B,IAAA/B,EAAAU,UAAA,CAAAuoB,OAAA,CACAC,EAAAlpB,KAAA+B,IAAA/B,EAAAU,UAAA,CAAArE,KAAA,CACA8sB,EAAAnpB,KAAA+B,IAAA/B,EAAAU,UAAA,CAAAtE,MAAA,CAEA,GAAAqb,EAAA2R,QAAA,EAEA,IAAAzZ,EAAA,kBAAAwJ,EAAAkQ,IAAA,CAEAC,EAAA,KAAAza,KAAA,CAAA/P,GAAA,CAAA6Q,GAEA2Z,IAEAA,EAAA,IAAyBhhB,EAAAihB,cAAc,CACnCjhB,EAAAkhB,QAAA,CAAA9P,SAAA,CAAAC,IAAA,CAAAC,IAA4B,CAAA0P,EAAAnQ,GAChCmQ,EAAAjtB,KAAA,CAAAsd,IAAA,CAAAR,EAAA9c,KAAA,EACAitB,EAAArlB,GAAA,CAAAkV,EAAAlV,GAAA,CACAqlB,EAAAG,eAAA,IAEA,KAAA5a,KAAA,CAAAlB,GAAA,CAAAgC,EAAA2Z,IAIAnQ,EAAAmQ,CAEA,MAAI,GAAA7R,EAAAiS,MAAA,EAEJ,IAAA/Z,EAAA,qBAAAwJ,EAAAkQ,IAAA,CAEAM,EAAA,KAAA9a,KAAA,CAAA/P,GAAA,CAAA6Q,GAEAga,IAEAA,EAAA,IAAuBrhB,EAAAshB,iBAAiB,CACpCthB,EAAAkhB,QAAA,CAAA9P,SAAA,CAAAC,IAAA,CAAAC,IAA4B,CAAA+P,EAAAxQ,GAChCwQ,EAAAttB,KAAA,CAAAsd,IAAA,CAAAR,EAAA9c,KAAA,EAEA,KAAAwS,KAAA,CAAAlB,GAAA,CAAAgC,EAAAga,IAIAxQ,EAAAwQ,CAEA,IAGAX,GAAAE,GAAAC,EAAA,CAEA,IAAAxZ,EAAA,kBAAAwJ,EAAAkQ,IAAA,KAEAL,GAAArZ,CAAAA,GAAA,wBACAuZ,GAAAvZ,CAAAA,GAAA,kBACAwZ,GAAAxZ,CAAAA,GAAA,iBAEA,IAAAka,EAAA,KAAAhb,KAAA,CAAA/P,GAAA,CAAA6Q,GAEAka,IAEAA,EAAA1Q,EAAAjQ,KAAA,GAEAggB,GAAAW,CAAAA,EAAAC,YAAA,KACAX,GAAAU,CAAAA,EAAAE,WAAA,KAEAf,IAGAa,EAAAG,WAAA,EAAAH,CAAAA,EAAAG,WAAA,CAAAC,CAAA,MACAJ,EAAA1W,oBAAA,EAAA0W,CAAAA,EAAA1W,oBAAA,CAAA8W,CAAA,OAIA,KAAApb,KAAA,CAAAlB,GAAA,CAAAgC,EAAAka,GAEA,KAAA5H,YAAA,CAAA/hB,GAAA,CAAA2pB,EAAA,KAAA5H,YAAA,CAAAnjB,GAAA,CAAAqa,KAIAA,EAAA0Q,CAEA,GAIAK,KAAA,EAAAlqB,KAAA+B,IAAA/B,EAAAU,UAAA,CAAAypB,GAAA,EAAAnqB,KAAA+B,IAAA/B,EAAAU,UAAA,CAAApE,EAAA,EAEA0D,EAAAiB,YAAA,OAAAjB,EAAAU,UAAA,CAAApE,EAAA,EAIAmb,EAAA0B,QAAA,CAAAA,CAEA,CAEA9H,iBAAA,CAEA,OAAS/I,EAAA8hB,oBAAoB,CAS7B5E,aAAAnT,CAAA,MAOAgY,EALA,IAAA3gB,EAAA,KACA8B,EAAA,KAAAA,IAAA,CACAC,EAAA,KAAAA,UAAA,CACAgG,EAAAjG,EAAA8G,SAAA,CAAAD,EAAA,CAGAb,EAAA,GACA8Y,EAAA7Y,EAAAhG,UAAA,KAEAiG,EAAA,GAEA,GAAA4Y,CAAA,CAAAre,EAAAa,mBAAA,GAEA,IAAAyd,EAAA9e,CAAA,CAAAQ,EAAAa,mBAAA,EACAud,EAAAE,EAAAlZ,eAAA,GACAK,EAAArP,IAAA,CAAAkoB,EAAAhZ,YAAA,CAAAC,EAAAC,EAAA/H,GAEA,KAAI,CAKJ,IAAAkI,EAAAH,EAAAI,oBAAA,KAKA,GAHAL,EAAAnV,KAAA,KAA8BiM,EAAAlH,KAAK,QACnCoQ,EAAAG,OAAA,GAEAG,MAAAC,OAAA,CAAAH,EAAAI,eAAA,GAEA,IAAAxR,EAAAoR,EAAAI,eAAA,CAEAR,EAAAnV,KAAA,CAAA2T,SAAA,CAAAxP,GACAgR,EAAAG,OAAA,CAAAnR,CAAA,IAEA,KAEAuB,IAAA6P,EAAAK,gBAAA,EAEAP,EAAArP,IAAA,CAAAqH,EAAAwI,aAAA,CAAAV,EAAA,MAAAI,EAAAK,gBAAA,CAAmG3J,EAAA6J,YAAY,GAI/GX,EAAAgZ,SAAA,CAAA5Y,KAAA7P,IAAA6P,EAAA6Y,cAAA,CAAA7Y,EAAA6Y,cAAA,GACAjZ,EAAAkZ,SAAA,CAAA9Y,KAAA7P,IAAA6P,EAAA+Y,eAAA,CAAA/Y,EAAA+Y,eAAA,GAEA5oB,KAAAA,IAAA6P,EAAAgZ,wBAAA,GAEAlZ,EAAArP,IAAA,CAAAqH,EAAAwI,aAAA,CAAAV,EAAA,eAAAI,EAAAgZ,wBAAA,GACAlZ,EAAArP,IAAA,CAAAqH,EAAAwI,aAAA,CAAAV,EAAA,eAAAI,EAAAgZ,wBAAA,IAIAP,EAAA,KAAArF,UAAA,UAAAzB,CAAA,EAEA,OAAAA,EAAAlS,eAAA,EAAAkS,EAAAlS,eAAA,CAAAgB,EAEA,GAEAX,EAAArP,IAAA,CAAA9C,QAAA+C,GAAA,MAAAghB,UAAA,UAAAC,CAAA,EAEA,OAAAA,EAAAnR,oBAAA,EAAAmR,EAAAnR,oBAAA,CAAAC,EAAAb,EAEA,IAEA,EAEA,IAAAC,EAAAoZ,WAAA,EAEArZ,CAAAA,EAAAsZ,IAAA,CAAyBxiB,EAAAyiB,UAAU,EAInC,IAAAC,EAAAvZ,EAAAuZ,SAAA,EAAAjK,EAAAC,MAAA,CAqBA,GAnBAgK,IAAAjK,EAAAG,KAAA,EAEA1P,EAAAyZ,WAAA,IAGAzZ,EAAA0Z,UAAA,MAIA1Z,EAAAyZ,WAAA,IAEAD,IAAAjK,EAAAE,IAAA,EAEAzP,CAAAA,EAAA2Z,SAAA,CAAA1Z,KAAA1P,IAAA0P,EAAA2Z,WAAA,CAAA3Z,EAAA2Z,WAAA,MAMA3Z,KAAA1P,IAAA0P,EAAA4Z,aAAA,EAAAhB,IAAmE/hB,EAAAgJ,iBAAiB,GAEpFI,EAAArP,IAAA,CAAAqH,EAAAwI,aAAA,CAAAV,EAAA,YAAAC,EAAA4Z,aAAA,GAEA7Z,EAAAwY,WAAA,KAAoC1hB,EAAA8K,OAAO,MAE3C3B,KAAA1P,IAAA0P,EAAA4Z,aAAA,CAAAnY,KAAA,GAEA,IAAAA,EAAAzB,EAAA4Z,aAAA,CAAAnY,KAAA,CAEA1B,EAAAwY,WAAA,CAAA9pB,GAAA,CAAAgT,EAAAA,EAEA,CAEA,OAEAnR,KAAAA,IAAA0P,EAAA6Z,gBAAA,EAAAjB,IAAsE/hB,EAAAgJ,iBAAiB,GAEvFI,EAAArP,IAAA,CAAAqH,EAAAwI,aAAA,CAAAV,EAAA,QAAAC,EAAA6Z,gBAAA,GAEAvpB,KAAAA,IAAA0P,EAAA6Z,gBAAA,CAAAC,QAAA,EAEA/Z,CAAAA,EAAAga,cAAA,CAAA/Z,EAAA6Z,gBAAA,CAAAC,QAAA,GAMAxpB,KAAAA,IAAA0P,EAAAga,cAAA,EAAApB,IAAoE/hB,EAAAgJ,iBAAiB,EAErFE,CAAAA,EAAAka,QAAA,KAAiCpjB,EAAAlH,KAAK,GAAA4O,SAAA,CAAAyB,EAAAga,cAAA,GAItC1pB,KAAAA,IAAA0P,EAAAka,eAAA,EAAAtB,IAAqE/hB,EAAAgJ,iBAAiB,EAEtFI,EAAArP,IAAA,CAAAqH,EAAAwI,aAAA,CAAAV,EAAA,cAAAC,EAAAka,eAAA,CAAmGrjB,EAAA6J,YAAY,GAI/G5S,QAAA+C,GAAA,CAAAoP,GAAAnT,IAAA,YAEA,IAAA4a,EAAA,IAAAkR,EAAA7Y,GAUA,OARAC,EAAA5Q,IAAA,EAAAsY,CAAAA,EAAAtY,IAAA,CAAA4Q,EAAA5Q,IAAA,EAEAkQ,EAAAoI,EAAA1H,GAEA/H,EAAAuY,YAAA,CAAA/hB,GAAA,CAAAiZ,EAAA,CAAwC7G,UAAAD,CAAA,GAExCZ,EAAAhG,UAAA,EAAA0V,EAAA1V,EAAA0N,EAAA1H,GAEA0H,CAEA,EAEA,CAGAlI,iBAAA2a,CAAA,EAEA,IAAAC,EAAwBvjB,EAAAwjB,eAAA,CAAAC,gBAAgC,CAAAH,GAAA,IAExD/qB,EAAAgrB,EAEA,QAAAprB,EAAA,EAAmB,KAAAiiB,aAAA,CAAA7hB,EAAA,CAA4B,EAAAJ,EAE/CI,EAAAgrB,EAAA,IAAAprB,EAMA,OAFA,KAAAiiB,aAAA,CAAA7hB,EAAA,IAEAA,CAEA,CAUAmrB,eAAAnU,CAAA,EAEA,IAAAnO,EAAA,KACA+B,EAAA,KAAAA,UAAA,CACAoD,EAAA,KAAAsT,cAAA,CAcAzQ,EAAA,GAEA,QAAAjR,EAAA,EAAAY,EAAAwW,EAAAlX,MAAA,CAA2CF,EAAAY,EAAQZ,IAAA,CAEnD,IAAAmX,EAAAC,CAAA,CAAApX,EAAA,CACAkP,EAAAsc,SAvsCAC,CAAA,EAEA,IAAAC,EAAAD,EAAAzgB,UAAA,EAAAygB,EAAAzgB,UAAA,CAAAQ,EAAAe,0BAAA,EAeA,OAZAmf,EAEA,SAAAA,EAAAxV,UAAA,CACA,IAAAwV,EAAAvjB,OAAA,CACA,IAAAgZ,EAAAuK,EAAAzrB,UAAA,EAIAwrB,EAAAtjB,OAAA,KAAAgZ,EAAAsK,EAAAxrB,UAAA,MAAAwrB,EAAA9U,IAAA,EA0rCAQ,GAGAwU,EAAAvd,CAAA,CAAAc,EAAA,CAEA,GAAAyc,EAGA1a,EAAArP,IAAA,CAAA+pB,EAAAptB,OAAA,MAEK,CAEL,IAAAqtB,EAKAA,EAHAzU,EAAAnM,UAAA,EAAAmM,EAAAnM,UAAA,CAAAQ,EAAAe,0BAAA,EAGAsf,SAlCA1U,CAAA,EAEA,OAAAnM,CAAA,CAAAQ,EAAAe,0BAAA,EACA6N,eAAA,CAAAjD,EAAAlO,GACAnL,IAAA,UAAAyB,CAAA,EAEA,OAAAusB,EAAAvsB,EAAA4X,EAAAlO,EAEA,EAEA,EAwBAkO,GAKA2U,EAAA,IAAmDjkB,EAAAlI,cAAc,CAAAwX,EAAAlO,GAKjEmF,CAAA,CAAAc,EAAA,EAA0BiI,UAAAA,EAAA5Y,QAAAqtB,CAAA,EAE1B3a,EAAArP,IAAA,CAAAgqB,EAEA,EAIA,OAAA9sB,QAAA+C,GAAA,CAAAoP,EAEA,CAOA2T,SAAAmH,CAAA,EAEA,IAAA9iB,EAAA,KACA8B,EAAA,KAAAA,IAAA,CACAC,EAAA,KAAAA,UAAA,CAEAiM,EAAAlM,EAAAmM,MAAA,CAAA6U,EAAA,CACA3U,EAAAH,EAAAG,UAAA,CAEAnG,EAAA,GAEA,QAAAjR,EAAA,EAAAY,EAAAwW,EAAAlX,MAAA,CAA2CF,EAAAY,EAAQZ,IAAA,KA77CnDoO,EA+7CA,IAAAsK,EAAAtB,KAAA9V,IAAA8V,CAAA,CAAApX,EAAA,CAAA0Y,QAAA,EA77CApX,KAAAA,IAAA8M,CAFAA,EAg8CA,KAAAA,KAAA,EA97CA,iBAEAA,CAAAA,EAAA,oBAAmCvG,EAAA8hB,oBAAoB,EACvD/tB,MAAA,SACAqvB,SAAA,EACAlB,UAAA,EACAE,UAAA,EACAO,YAAA,GACAwB,UAAA,GACA3B,KAASxiB,EAAAokB,SAAS,EACd,EAIJ7d,EAAA,iBAi7CA,KAAAqC,aAAA,YAAA2G,CAAA,CAAApX,EAAA,CAAA0Y,QAAA,EAEAzH,EAAArP,IAAA,CAAA8W,EAEA,CAIA,OAFAzH,EAAArP,IAAA,CAAAqH,EAAAsiB,cAAA,CAAAnU,IAEAtY,QAAA+C,GAAA,CAAAoP,GAAAnT,IAAA,UAAA6Z,CAAA,EAEA,IAAA9F,EAAA8F,EAAA1Q,KAAA,GAAA0Q,EAAAzX,MAAA,IACAgsB,EAAAvU,CAAA,CAAAA,EAAAzX,MAAA,IAEAgX,EAAA,GAEA,QAAAlX,EAAA,EAAAY,EAAAsrB,EAAAhsB,MAAA,CAA4CF,EAAAY,EAAQZ,IAAA,KAOpDgX,EALA,IAAAzX,EAAA2sB,CAAA,CAAAlsB,EAAA,CACAmX,EAAAC,CAAA,CAAApX,EAAA,CAMA0Y,EAAA7G,CAAA,CAAA7R,EAAA,CAEA,GAAAmX,EAAAR,IAAA,GAAAU,EAAAC,SAAA,EACAH,EAAAR,IAAA,GAAAU,EAAAE,cAAA,EACAJ,EAAAR,IAAA,GAAAU,EAAAG,YAAA,EACAL,KAAA7V,IAAA6V,EAAAR,IAAA,CAOA,KAAAK,CAJAA,EAAAC,CAAA,IAAAA,EAAA8M,aAAA,CACA,IAAYlc,EAAAskB,WAAW,CAAA5sB,EAAAmZ,GACvB,IAAY7Q,EAAAtD,IAAI,CAAAhF,EAAAmZ,EAAA,EAEhBqL,aAAA,EAGA/M,EAAAoV,oBAAA,GAIAjV,EAAAR,IAAA,GAAAU,EAAAE,cAAA,CAEAP,EAAAzX,QAAA,CAAsBoI,EAAmBqP,EAAAzX,QAAA,CAAiBsI,EAAAI,qBAAqB,EAExEkP,EAAAR,IAAA,GAAAU,EAAAG,YAAA,EAEPR,CAAAA,EAAAzX,QAAA,CAAsBoI,EAAmBqP,EAAAzX,QAAA,CAAiBsI,EAAAG,mBAAmB,QAIvE,GAAAmP,EAAAR,IAAA,GAAAU,EAAAgH,KAAA,CAENrH,EAAA,IAAgBnP,EAAAwkB,YAAY,CAAA9sB,EAAAmZ,QAEtB,GAAAvB,EAAAR,IAAA,GAAAU,EAAAkH,UAAA,CAENvH,EAAA,IAAgBnP,EAAAykB,IAAI,CAAA/sB,EAAAmZ,QAEd,GAAAvB,EAAAR,IAAA,GAAAU,EAAAiH,SAAA,CAENtH,EAAA,IAAgBnP,EAAA0kB,QAAQ,CAAAhtB,EAAAmZ,QAElB,GAAAvB,EAAAR,IAAA,GAAAU,EAAA+G,MAAA,CAENpH,EAAA,IAAgBnP,EAAA2kB,MAAM,CAAAjtB,EAAAmZ,QAItB,6DAAAvB,EAAAR,IAAA,EAIAsK,OAAAI,IAAA,CAAArK,EAAAzX,QAAA,CAAAktB,eAAA,EAAAvsB,MAAA,IAEAwsB,SAt3CA1V,CAAA,CAAAC,CAAA,EAIA,GAFAD,EAAA0V,kBAAA,GAEAzV,KAAA3V,IAAA2V,EAAA+I,OAAA,CAEA,QAAAhgB,EAAA,EAAAY,EAAAqW,EAAA+I,OAAA,CAAA9f,MAAA,CAAgDF,EAAAY,EAAQZ,IAExDgX,EAAA2V,qBAAA,CAAA3sB,EAAA,CAAAiX,EAAA+I,OAAA,CAAAhgB,EAAA,CAOA,GAAAiX,EAAA+J,MAAA,EAAA3P,MAAAC,OAAA,CAAA2F,EAAA+J,MAAA,CAAA4L,WAAA,GAEA,IAAAA,EAAA3V,EAAA+J,MAAA,CAAA4L,WAAA,CAEA,GAAA5V,EAAA2V,qBAAA,CAAAzsB,MAAA,GAAA0sB,EAAA1sB,MAAA,EAEA8W,EAAA6V,qBAAA,IAEA,QAAA7sB,EAAA,EAAAY,EAAAgsB,EAAA1sB,MAAA,CAA6CF,EAAAY,EAAQZ,IAErDgX,EAAA6V,qBAAA,CAAAD,CAAA,CAAA5sB,EAAA,EAAAA,CAIA,MAEAkD,QAAA6E,IAAA,wEAEA,CAEA,EAm1CAiP,EAAAC,GAIAD,EAAA5W,IAAA,CAAA6I,EAAAuH,gBAAA,CAAAyG,EAAA7W,IAAA,UAAA2rB,GAEAzb,EAAA0G,EAAAC,GAEAE,EAAAnM,UAAA,EAAA0V,EAAA1V,EAAAgM,EAAAG,GAEAlO,EAAAoQ,mBAAA,CAAArC,GAEAE,EAAAtV,IAAA,CAAAoV,EAEA,CAEA,QAAAhX,EAAA,EAAAY,EAAAsW,EAAAhX,MAAA,CAAwCF,EAAAY,EAAQZ,IAEhDiJ,EAAAuY,YAAA,CAAA/hB,GAAA,CAAAyX,CAAA,CAAAlX,EAAA,EACAkX,OAAA6U,EACA3U,WAAApX,CACA,GAIA,GAAAkX,IAAAA,EAAAhX,MAAA,CAEA,OAAAgX,CAAA,IAIA,IAAA4V,EAAA,IAAqBjlB,EAAAklB,KAAK,CAE1B9jB,EAAAuY,YAAA,CAAA/hB,GAAA,CAAAqtB,EAAA,CAAqC5V,OAAA6U,CAAA,GAErC,QAAA/rB,EAAA,EAAAY,EAAAsW,EAAAhX,MAAA,CAAwCF,EAAAY,EAAQZ,IAEhD8sB,EAAA5f,GAAA,CAAAgK,CAAA,CAAAlX,EAAA,EAIA,OAAA8sB,CAEA,EAEA,CAOA5H,WAAA8H,CAAA,MAEAhJ,EACA,IAAAiJ,EAAA,KAAAliB,IAAA,CAAAsY,OAAA,CAAA2J,EAAA,CACAE,EAAAD,CAAA,CAAAA,EAAA9tB,IAAA,EAEA,IAAA+tB,EAAA,CAEAhqB,QAAA6E,IAAA,iDACA,MAEA,OAEAklB,gBAAAA,EAAA9tB,IAAA,CAEA6kB,EAAA,IAAgBnc,EAAAslB,iBAAiB,CAAEtlB,EAAAulB,SAAA,CAAAC,QAAkB,CAAAH,EAAAI,IAAA,EAAAJ,EAAAK,WAAA,IAAAL,EAAAM,KAAA,IAAAN,EAAAO,IAAA,OAEjD,iBAAAR,EAAA9tB,IAAA,EAEJ6kB,CAAAA,EAAA,IAAgBnc,EAAA6lB,kBAAkB,EAAAR,EAAAS,IAAA,CAAAT,EAAAS,IAAA,CAAAT,EAAAU,IAAA,EAAAV,EAAAU,IAAA,CAAAV,EAAAM,KAAA,CAAAN,EAAAO,IAAA,GAIlCR,EAAA7sB,IAAA,EAAA4jB,CAAAA,EAAA5jB,IAAA,MAAAoQ,gBAAA,CAAAyc,EAAA7sB,IAAA,GAEAkQ,EAAA0T,EAAAiJ,GAEAnuB,QAAAC,OAAA,CAAAilB,EAEA,CAOAgB,SAAAtB,CAAA,EAEA,IAAAmK,EAAA,KAAA9iB,IAAA,CAAAyY,KAAA,CAAAE,EAAA,CAEAzS,EAAA,GAEA,QAAAjR,EAAA,EAAAY,EAAAitB,EAAAjK,MAAA,CAAA1jB,MAAA,CAA+CF,EAAAY,EAAQZ,IAEvDiR,EAAArP,IAAA,MAAAksB,gBAAA,CAAAD,EAAAjK,MAAA,CAAA5jB,EAAA,GAcA,OAVA6tB,KAAAvsB,IAAAusB,EAAAE,mBAAA,CAEA9c,EAAArP,IAAA,MAAA6O,aAAA,YAAAod,EAAAE,mBAAA,GAIA9c,EAAArP,IAAA,OAIA9C,QAAA+C,GAAA,CAAAoP,GAAAnT,IAAA,UAAA6Z,CAAA,EAEA,IAAAoW,EAAApW,EAAAE,GAAA,GAMAmW,EAAA,GACAC,EAAA,GAEA,QAAAjuB,EAAA,EAAAY,EAAAstB,EAAAhuB,MAAA,CAA4CF,EAAAY,EAAQZ,IAAA,CAEpD,IAAAmuB,EAAAD,CAAA,CAAAluB,EAAA,CAEA,GAAAmuB,EAAA,CAEAH,EAAApsB,IAAA,CAAAusB,GAEA,IAAAC,EAAA,IAAqBvmB,EAAAqQ,OAAO,CAE5B,OAAA6V,GAEAK,EAAA7e,SAAA,CAAAwe,EAAAhuB,KAAA,CAAAC,GAAAA,GAIAiuB,EAAArsB,IAAA,CAAAwsB,EAEA,MAEAlrB,QAAA6E,IAAA,oDAAA8lB,EAAAjK,MAAA,CAAA5jB,EAAA,CAEA,CAIA,WAAc6H,EAAAwmB,QAAQ,CAAAL,EAAAC,EAEtB,EAEA,CAOAhJ,cAAAqJ,CAAA,EAEA,IAAAvjB,EAAA,KAAAA,IAAA,CAEAwjB,EAAAxjB,EAAAqY,UAAA,CAAAkL,EAAA,CAEAE,EAAA,GACAC,EAAA,GACAC,EAAA,GACAC,EAAA,GACAC,EAAA,GAEA,QAAA5uB,EAAA,EAAAY,EAAA2tB,EAAAM,QAAA,CAAA3uB,MAAA,CAAsDF,EAAAY,EAAQZ,IAAA,CAE9D,IAAA8uB,EAAAP,EAAAM,QAAA,CAAA7uB,EAAA,CACAknB,EAAAqH,EAAAlH,QAAA,CAAAyH,EAAA5H,OAAA,EACAxX,EAAAof,EAAApf,MAAA,CACAtP,EAAAsP,EAAAqf,IAAA,CACAC,EAAAT,KAAAjtB,IAAAitB,EAAAU,UAAA,CAAAV,EAAAU,UAAA,CAAA/H,EAAA8H,KAAA,EAAA9H,EAAA8H,KAAA,CACAE,EAAAX,KAAAjtB,IAAAitB,EAAAU,UAAA,CAAAV,EAAAU,UAAA,CAAA/H,EAAAgI,MAAA,EAAAhI,EAAAgI,MAAA,CAEAV,EAAA5sB,IAAA,MAAA6O,aAAA,QAAArQ,IACAquB,EAAA7sB,IAAA,MAAA6O,aAAA,YAAAue,IACAN,EAAA9sB,IAAA,MAAA6O,aAAA,YAAAye,IACAP,EAAA/sB,IAAA,CAAAslB,GACA0H,EAAAhtB,IAAA,CAAA8N,EAEA,CAEA,OAAA5Q,QAAA+C,GAAA,EAEA/C,QAAA+C,GAAA,CAAA2sB,GACA1vB,QAAA+C,GAAA,CAAA4sB,GACA3vB,QAAA+C,GAAA,CAAA6sB,GACA5vB,QAAA+C,GAAA,CAAA8sB,GACA7vB,QAAA+C,GAAA,CAAA+sB,GAEA,EAAA9wB,IAAA,UAAAmlB,CAAA,EAEA,IAAAxU,EAAAwU,CAAA,IACAkM,EAAAlM,CAAA,IACAmM,EAAAnM,CAAA,IACAoE,EAAApE,CAAA,IACAoM,EAAApM,CAAA,IAEAqM,EAAA,GAEA,QAAAtvB,EAAA,EAAAY,EAAA6N,EAAAvO,MAAA,CAAuCF,EAAAY,EAAQZ,IAAA,KAY/CuvB,EAVA,IAAAR,EAAAtgB,CAAA,CAAAzO,EAAA,CACAwvB,EAAAL,CAAA,CAAAnvB,EAAA,CACAyvB,EAAAL,CAAA,CAAApvB,EAAA,CACAknB,EAAAG,CAAA,CAAArnB,EAAA,CACA0P,EAAA2f,CAAA,CAAArvB,EAAA,CAEA,GAAA+uB,KAAAztB,IAAAytB,EAAA,SAMA,OAJAA,EAAAW,YAAA,GAIA5P,CAAA,CAAApQ,EAAA1T,IAAA,GAEA,KAAA8jB,EAAAE,OAAA,CAEAuP,EAA2B1nB,EAAA8nB,mBAAmB,CAC9C,WAEA7P,EAAAvE,QAAA,CAEAgU,EAA2B1nB,EAAA+nB,uBAAuB,CAClD,WAEA9P,EAAApkB,QAAA,CACA,KAAAokB,EAAArN,KAAA,CACA,QAEA8c,EAA2B1nB,EAAAgoB,mBAAmB,CAK9C,IAAAC,EAAAf,EAAA3uB,IAAA,CAAA2uB,EAAA3uB,IAAA,CAAA2uB,EAAAnG,IAAA,CAEAmH,EAAA7I,KAAA5lB,IAAA4lB,EAAA6I,aAAA,CAAA9P,CAAA,CAAAiH,EAAA6I,aAAA,EAAyGloB,EAAAsY,iBAAiB,CAE1HyM,EAAA,GAEA9M,CAAA,CAAApQ,EAAA1T,IAAA,IAAA8jB,EAAAE,OAAA,CAEA+O,EAAAiB,QAAA,UAAA7iB,CAAA,EAEAA,EAAAwf,qBAAA,EAEAC,EAAAhrB,IAAA,CAAAuL,EAAA/M,IAAA,CAAA+M,EAAA/M,IAAA,CAAA+M,EAAAyb,IAAA,CAIA,GAIAgE,EAAAhrB,IAAA,CAAAkuB,GAIA,IAAAG,EAAAR,EAAA1vB,KAAA,CAEA,GAAA0vB,EAAAxU,UAAA,EAEA,IAAAxI,EAAA6O,EAAA2O,EAAAl1B,WAAA,EACAm1B,EAAA,IAAAlqB,aAAAiqB,EAAA/vB,MAAA,EAEA,QAAAiwB,EAAA,EAAAC,EAAAH,EAAA/vB,MAAA,CAA+CiwB,EAAAC,EAAQD,IAEvDD,CAAA,CAAAC,EAAA,CAAAF,CAAA,CAAAE,EAAA,CAAA1d,EAIAwd,EAAAC,CAEA,KAEA,IAAAC,EAAA,EAAAC,EAAAxD,EAAA1sB,MAAA,CAA8CiwB,EAAAC,EAAQD,IAAA,CAEtD,IAAAE,EAAA,IAAAd,EACA3C,CAAA,CAAAuD,EAAA,KAAArQ,CAAA,CAAApQ,EAAA1T,IAAA,EACAwzB,EAAAzvB,KAAA,CACAkwB,EACAF,GAIA,gBAAA7I,EAAA6I,aAAA,GAEAM,EAAAC,iBAAA,UAAAnwB,CAAA,EAMA,IAAAowB,EAAA,gBAAiD1oB,EAAA+nB,uBAAuB,CAAApS,EAAA9B,CAAA,CAExE,WAAA6U,EAAA,KAAAC,KAAA,MAAAvU,MAAA,MAAAwU,YAAA,KAAAtwB,EAEA,EAGAkwB,EAAAC,iBAAA,CAAAI,yCAAA,KAIApB,EAAA1tB,IAAA,CAAAyuB,EAEA,CAEA,CAEA,IAAAjwB,EAAAmuB,EAAAnuB,IAAA,CAAAmuB,EAAAnuB,IAAA,cAAAkuB,CAAA,CAEA,WAAczmB,EAAA8oB,aAAa,CAAAvwB,EAAAkB,KAAAA,EAAAguB,EAE3B,EAEA,CAEAvY,eAAArI,CAAA,EAEA,IAAA3D,EAAA,KAAAA,IAAA,CACA9B,EAAA,KACA2F,EAAA7D,EAAA0D,KAAA,CAAAC,EAAA,QAEA,KAAApN,IAAAsN,EAAAoI,IAAA,MAEA/N,EAAAwH,aAAA,QAAA7B,EAAAoI,IAAA,EAAAlZ,IAAA,UAAAkZ,CAAA,EAEA,IAAA+X,EAAA9lB,EAAA0H,WAAA,CAAA1H,EAAA2Y,SAAA,CAAAhT,EAAAoI,IAAA,CAAAA,GAmBA,OAhBA1V,KAAAA,IAAAsN,EAAAoR,OAAA,EAEA+O,EAAAiB,QAAA,UAAAY,CAAA,EAEA,GAAAA,EAAAC,MAAA,CAEA,QAAA7wB,EAAA,EAAAY,EAAAgO,EAAAoR,OAAA,CAAA9f,MAAA,CAAmDF,EAAAY,EAAQZ,IAE3D4wB,EAAAjE,qBAAA,CAAA3sB,EAAA,CAAA4O,EAAAoR,OAAA,CAAAhgB,EAAA,GAQA+uB,CAEA,EAzBA,CAkCApK,SAAAjW,CAAA,EAEA,IAAA3D,EAAA,KAAAA,IAAA,CAGA6D,EAAA7D,EAAA0D,KAAA,CAAAC,EAAA,CAEAoiB,EAAA7nB,IAJA,CAIA6kB,gBAAA,CAAApf,GAEAqiB,EAAA,GACAC,EAAApiB,EAAAmJ,QAAA,KAEA,QAAA/X,EAAA,EAAAY,EAAAowB,EAAA9wB,MAAA,CAA4CF,EAAAY,EAAQZ,IAEpD+wB,EAAAnvB,IAAA,CAAAqH,IAXA,CAWAwH,aAAA,QAAAugB,CAAA,CAAAhxB,EAAA,GAIA,IAAAixB,EAAAriB,KAAAtN,IAAAsN,EAAAkV,IAAA,CACAhlB,QAAAC,OAAA,OACAkK,IAjBA,CAiBAwH,aAAA,QAAA7B,EAAAkV,IAAA,EAEA,OAAAhlB,QAAA+C,GAAA,EACAivB,EACAhyB,QAAA+C,GAAA,CAAAkvB,GACAE,EACA,EAAAnzB,IAAA,UAAA6Z,CAAA,EAEA,IAAAoX,EAAApX,CAAA,IACAI,EAAAJ,CAAA,IACAuZ,EAAAvZ,CAAA,IAEA,OAAAuZ,GAIAnC,EAAAiB,QAAA,UAAAhZ,CAAA,EAEAA,EAAA+M,aAAA,EAEA/M,EAAAma,IAAA,CAAAD,EAAA3P,EAEA,GAIA,QAAAvhB,EAAA,EAAAY,EAAAmX,EAAA7X,MAAA,CAA0CF,EAAAY,EAAQZ,IAElD+uB,EAAA7hB,GAAA,CAAA6K,CAAA,CAAA/X,EAAA,EAIA,OAAA+uB,CAEA,EAEA,CAIAjB,iBAAApf,CAAA,EAEA,IAAA3D,EAAA,KAAAA,IAAA,CACAC,EAAA,KAAAA,UAAA,CACA/B,EAAA,KAKA,QAAA3H,IAAA,KAAAqgB,SAAA,CAAAjT,EAAA,CAEA,YAAAiT,SAAA,CAAAjT,EAAA,CAIA,IAAAE,EAAA7D,EAAA0D,KAAA,CAAAC,EAAA,CAGA0iB,EAAAxiB,EAAAxO,IAAA,CAAA6I,EAAAuH,gBAAA,CAAA5B,EAAAxO,IAAA,KAEA6Q,EAAA,GAEAogB,EAAApoB,EAAAsb,UAAA,UAAAzB,CAAA,EAEA,OAAAA,EAAA/L,cAAA,EAAA+L,EAAA/L,cAAA,CAAArI,EAEA,GAgHA,OA9GA2iB,GAEApgB,EAAArP,IAAA,CAAAyvB,GAIA/vB,KAAAA,IAAAsN,EAAAoV,MAAA,EAEA/S,EAAArP,IAAA,CAAAqH,EAAAwH,aAAA,UAAA7B,EAAAoV,MAAA,EAAAlmB,IAAA,UAAAkmB,CAAA,EAEA,OAAA/a,EAAA0H,WAAA,CAAA1H,EAAA4Y,WAAA,CAAAjT,EAAAoV,MAAA,CAAAA,EAEA,IAIA/a,EAAA4Z,UAAA,UAAAC,CAAA,EAEA,OAAAA,EAAApS,oBAAA,EAAAoS,EAAApS,oBAAA,CAAAhC,EAEA,GAAI4iB,OAAA,UAAA/yB,CAAA,EAEJ0S,EAAArP,IAAA,CAAArD,EAEA,GAEA,KAAAojB,SAAA,CAAAjT,EAAA,CAAA5P,QAAA+C,GAAA,CAAAoP,GAAAnT,IAAA,UAAAmP,CAAA,EAEA,IAAA8hB,EAqBA,GAAAA,CAhBAA,EAFAngB,CAAA,IAAAA,EAAAiV,MAAA,CAEA,IAAehc,EAAA0pB,IAAI,CAEdtkB,EAAA/M,MAAA,GAEL,IAAe2H,EAAAklB,KAAK,CAEf9f,IAAAA,EAAA/M,MAAA,CAEL+M,CAAA,IAIA,IAAepF,EAAAmR,QAAQ,IAIvB/L,CAAA,IAEA,QAAAjN,EAAA,EAAAY,EAAAqM,EAAA/M,MAAA,CAA0CF,EAAAY,EAAQZ,IAElD+uB,EAAA7hB,GAAA,CAAAD,CAAA,CAAAjN,EAAA,CAIA,CAaA,GAXA4O,EAAAxO,IAAA,GAEA2uB,EAAAlO,QAAA,CAAAzgB,IAAA,CAAAwO,EAAAxO,IAAA,CACA2uB,EAAA3uB,IAAA,CAAAgxB,GAIA9gB,EAAAye,EAAAngB,GAEAA,EAAA5D,UAAA,EAAA0V,EAAA1V,EAAA+jB,EAAAngB,GAEAA,KAAAtN,IAAAsN,EAAA4iB,MAAA,EAEA,IAAAA,EAAA,IAAuB3pB,EAAAqQ,OAAO,CAC9BsZ,EAAAjiB,SAAA,CAAAX,EAAA4iB,MAAA,EACAzC,EAAA0C,YAAA,CAAAD,EAEA,MAEAlwB,KAAAA,IAAAsN,EAAAmR,WAAA,EAEAgP,EAAArzB,QAAA,CAAA6T,SAAA,CAAAX,EAAAmR,WAAA,EAIAze,KAAAA,IAAAsN,EAAA2M,QAAA,EAEAwT,EAAA2C,UAAA,CAAAniB,SAAA,CAAAX,EAAA2M,QAAA,EAIAja,KAAAA,IAAAsN,EAAA6D,KAAA,EAEAsc,EAAAtc,KAAA,CAAAlD,SAAA,CAAAX,EAAA6D,KAAA,CAIA,CAUA,OARAxJ,EAAAuY,YAAA,CAAArjB,GAAA,CAAA4wB,IAEA9lB,EAAAuY,YAAA,CAAA/hB,GAAA,CAAAsvB,EAAA,IAIA9lB,EAAAuY,YAAA,CAAAnjB,GAAA,CAAA0wB,GAAAtgB,KAAA,CAAAC,EAEAqgB,CAEA,GAEA,KAAApN,SAAA,CAAAjT,EAAA,CASAgW,UAAAiN,CAAA,EAEA,IAAA3mB,EAAA,KAAAA,UAAA,CACA4mB,EAAA,KAAA7mB,IAAA,CAAAoY,MAAA,CAAAwO,EAAA,CACA1oB,EAAA,KAIAia,EAAA,IAAoBrb,EAAAklB,KAAK,CACzB6E,EAAAxxB,IAAA,EAAA8iB,CAAAA,EAAA9iB,IAAA,CAAA6I,EAAAuH,gBAAA,CAAAohB,EAAAxxB,IAAA,GAEAkQ,EAAA4S,EAAA0O,GAEAA,EAAA5mB,UAAA,EAAA0V,EAAA1V,EAAAkY,EAAA0O,GAEA,IAAAC,EAAAD,EAAAnjB,KAAA,KAEAwC,EAAA,GAEA,QAAAjR,EAAA,EAAAY,EAAAixB,EAAA3xB,MAAA,CAAwCF,EAAAY,EAAQZ,IAEhDiR,EAAArP,IAAA,CAAAqH,EAAAwH,aAAA,QAAAohB,CAAA,CAAA7xB,EAAA,GAIA,OAAAlB,QAAA+C,GAAA,CAAAoP,GAAAnT,IAAA,UAAA2Q,CAAA,EAEA,QAAAzO,EAAA,EAAAY,EAAA6N,EAAAvO,MAAA,CAAuCF,EAAAY,EAAQZ,IAE/CkjB,EAAAhW,GAAA,CAAAuB,CAAA,CAAAzO,EAAA,EAsCA,OAFAiJ,EAAAuY,YAAA,CAAAsQ,CA9BA,IAEA,IAAAC,EAAA,IAAAtQ,IAEA,QAAAnjB,EAAA0zB,EAAA,GAAA/oB,EAAAuY,YAAA,CAEAljB,CAAAA,aAAyBuJ,EAAAkhB,QAAQ,EAAAzqB,aAAmBuJ,EAAAogB,OAAO,GAE3D8J,EAAAtyB,GAAA,CAAAnB,EAAA0zB,GAkBA,OAZAjD,EAAAiB,QAAA,KAEA,IAAA5L,EAAAnb,EAAAuY,YAAA,CAAAnjB,GAAA,CAAA0wB,GAEA,MAAA3K,GAEA2N,EAAAtyB,GAAA,CAAAsvB,EAAA3K,EAIA,GAEA2N,CAEA,GAEA7O,GAEAA,CAEA,EAEA,CAEA,CA2HA,SAAA4I,EAAAvsB,CAAA,CAAAksB,CAAA,CAAAxiB,CAAA,EAEA,IAAAhJ,EAAAwrB,EAAAxrB,UAAA,CAEAgR,EAAA,GAaA,QAAAghB,KAAAhyB,EAAA,CAEA,IAAAya,EAAAC,CAAA,CAAAsX,EAAA,EAAAA,EAAArX,WAAA,GAGAF,KAAAnb,EAAAU,UAAA,EAEAgR,EAAArP,IAAA,CAAAswB,SAlBAzM,CAAA,CAAA1gB,CAAA,EAEA,OAAAkE,EAAAwH,aAAA,YAAAgV,GACA3nB,IAAA,UAAA4Z,CAAA,EAEAnY,EAAAiB,YAAA,CAAAuE,EAAA2S,EAEA,EAEA,EASAzX,CAAA,CAAAgyB,EAAA,CAAAvX,GAEA,CAEA,GAAA+Q,KAAAnqB,IAAAmqB,EAAAtjB,OAAA,GAAA5I,EAAAK,KAAA,EAEA,IAAA8X,EAAAzO,EAAAwH,aAAA,YAAAgb,EAAAtjB,OAAA,EAAArK,IAAA,UAAA4Z,CAAA,EAEAnY,EAAAM,QAAA,CAAA6X,EAEA,GAEAzG,EAAArP,IAAA,CAAA8V,EAEA,QAEApH,EAAA/Q,EAAAksB,IAEA0G,SA9JA5yB,CAAA,CAAAksB,CAAA,CAAAxiB,CAAA,EAEA,IAAAhJ,EAAAwrB,EAAAxrB,UAAA,CAEAmyB,EAAA,IAAiBvqB,EAAAwqB,IAAI,CAErB,GAAApyB,KAAAqB,IAAArB,EAAAqf,QAAA,CAkCA,MAEA,EAlCA,IAAA5H,EAAAzO,EAAA8B,IAAA,CAAA+P,SAAA,CAAA7a,EAAAqf,QAAA,EAEAgT,EAAA5a,EAAA4a,GAAA,CACAC,EAAA7a,EAAA6a,GAAA,CAIA,GAAAD,KAAAhxB,IAAAgxB,GAAAC,KAAAjxB,IAAAixB,EAOA,IALAH,EAAA3yB,GAAA,CACA,IAAQoI,EAAAuQ,OAAO,CAAAka,CAAA,IAAAA,CAAA,IAAAA,CAAA,KACf,IAAQzqB,EAAAuQ,OAAO,CAAAma,CAAA,IAAAA,CAAA,IAAAA,CAAA,MAGf7a,EAAAuD,UAAA,EAEA,IAAAuX,EAAAlR,EAAAtG,CAAA,CAAAtD,EAAAqD,aAAA,GACAqX,EAAAE,GAAA,CAAAG,cAAA,CAAAD,GACAJ,EAAAG,GAAA,CAAAE,cAAA,CAAAD,EAEA,MAEI,CAEJtvB,QAAA6E,IAAA,wEAEA,MAEA,EAQA,IAAAsnB,EAAA5D,EAAA4D,OAAA,CAEA,GAAAA,KAAA/tB,IAAA+tB,EAAA,CAEA,IAAAqD,EAAA,IAA8B7qB,EAAAuQ,OAAO,CACrCua,EAAA,IAAqB9qB,EAAAuQ,OAAO,CAE5B,QAAApY,EAAA,EAAAY,EAAAyuB,EAAAnvB,MAAA,CAAwCF,EAAAY,EAAQZ,IAAA,CAEhD,IAAA0P,EAAA2f,CAAA,CAAArvB,EAAA,CAEA,GAAA0P,KAAApO,IAAAoO,EAAA4P,QAAA,EAEA,IAAA5H,EAAAzO,EAAA8B,IAAA,CAAA+P,SAAA,CAAApL,EAAA4P,QAAA,EACAgT,EAAA5a,EAAA4a,GAAA,CACAC,EAAA7a,EAAA6a,GAAA,CAIA,GAAAD,KAAAhxB,IAAAgxB,GAAAC,KAAAjxB,IAAAixB,EAAA,CAQA,GALAI,EAAA/L,IAAA,CAAA3W,KAAAsiB,GAAA,CAAAtiB,KAAA2iB,GAAA,CAAAN,CAAA,KAAAriB,KAAA2iB,GAAA,CAAAL,CAAA,OACAI,EAAA9L,IAAA,CAAA5W,KAAAsiB,GAAA,CAAAtiB,KAAA2iB,GAAA,CAAAN,CAAA,KAAAriB,KAAA2iB,GAAA,CAAAL,CAAA,OACAI,EAAA7L,IAAA,CAAA7W,KAAAsiB,GAAA,CAAAtiB,KAAA2iB,GAAA,CAAAN,CAAA,KAAAriB,KAAA2iB,GAAA,CAAAL,CAAA,OAGA7a,EAAAuD,UAAA,EAEA,IAAAuX,EAAAlR,EAAAtG,CAAA,CAAAtD,EAAAqD,aAAA,GACA4X,EAAAF,cAAA,CAAAD,EAEA,GAMAD,GAAA,CAAAI,EAEA,MAEAzvB,QAAA6E,IAAA,uEAEA,CAEA,CAKAqqB,EAAAS,cAAA,CAAAH,EAEA,GAEAI,WAAA,CAAAV,EAEA,IAAAW,EAAA,IAAoBlrB,EAAAmrB,MAAM,CAE1BZ,EAAAa,SAAA,CAAAF,EAAAG,MAAA,EACAH,EAAAI,MAAA,CAAAf,EAAAE,GAAA,CAAAc,UAAA,CAAAhB,EAAAG,GAAA,IAEAhzB,EAAA8zB,cAAA,CAAAN,CAEA,EAkDAxzB,EAAAksB,EAAAxiB,GAEAnK,QAAA+C,GAAA,CAAAoP,GAAAnT,IAAA,YAEA,OAAA2tB,KAAAnqB,IAAAmqB,EAAA4D,OAAA,CACAiE,SAzvEA/zB,CAAA,CAAA8vB,CAAA,CAAApmB,CAAA,EAEA,IAAAsqB,EAAA,GACAC,EAAA,GACAC,EAAA,GAEA,QAAAzzB,EAAA,EAAAY,EAAAyuB,EAAAnvB,MAAA,CAAuCF,EAAAY,EAAQZ,IAAA,CAE/C,IAAA0P,EAAA2f,CAAA,CAAArvB,EAAA,CAMA,GAJAsB,KAAAA,IAAAoO,EAAA4P,QAAA,EAAAiU,CAAAA,EAAA,IACAjyB,KAAAA,IAAAoO,EAAA6P,MAAA,EAAAiU,CAAAA,EAAA,IACAlyB,KAAAA,IAAAoO,EAAAiQ,OAAA,EAAA8T,CAAAA,EAAA,IAEAF,GAAAC,GAAAC,EAAA,MAIA,IAAAF,GAAA,CAAAC,GAAA,CAAAC,EAAA,OAAA30B,QAAAC,OAAA,CAAAQ,EAAA,CAEA,IAAAm0B,EAAA,GACAC,EAAA,GACAC,EAAA,GAEA,QAAA5zB,EAAA,EAAAY,EAAAyuB,EAAAnvB,MAAA,CAAuCF,EAAAY,EAAQZ,IAAA,CAE/C,IAAA0P,EAAA2f,CAAA,CAAArvB,EAAA,CAEA,GAAAuzB,EAAA,CAEA,IAAAM,EAAAnkB,KAAApO,IAAAoO,EAAA4P,QAAA,CACArW,EAAAwH,aAAA,YAAAf,EAAA4P,QAAA,EACA/f,EAAAU,UAAA,CAAAvE,QAAA,CAEAg4B,EAAA9xB,IAAA,CAAAiyB,EAEA,IAEAL,EAAA,CAEA,IAAAK,EAAAnkB,KAAApO,IAAAoO,EAAA6P,MAAA,CACAtW,EAAAwH,aAAA,YAAAf,EAAA6P,MAAA,EACAhgB,EAAAU,UAAA,CAAAtE,MAAA,CAEAg4B,EAAA/xB,IAAA,CAAAiyB,EAEA,IAEAJ,EAAA,CAEA,IAAAI,EAAAnkB,KAAApO,IAAAoO,EAAAiQ,OAAA,CACA1W,EAAAwH,aAAA,YAAAf,EAAAiQ,OAAA,EACApgB,EAAAU,UAAA,CAAArE,KAAA,CAEAg4B,EAAAhyB,IAAA,CAAAiyB,EAEA,EAIA,OAAA/0B,QAAA+C,GAAA,EACA/C,QAAA+C,GAAA,CAAA6xB,GACA50B,QAAA+C,GAAA,CAAA8xB,GACA70B,QAAA+C,GAAA,CAAA+xB,GACA,EAAA91B,IAAA,UAAAgd,CAAA,EAEA,IAAAgZ,EAAAhZ,CAAA,IACAiZ,EAAAjZ,CAAA,IACAkZ,EAAAlZ,CAAA,IAOA,OALAyY,GAAAh0B,CAAAA,EAAAktB,eAAA,CAAA/wB,QAAA,CAAAo4B,CAAA,EACAN,GAAAj0B,CAAAA,EAAAktB,eAAA,CAAA9wB,MAAA,CAAAo4B,CAAA,EACAN,GAAAl0B,CAAAA,EAAAktB,eAAA,CAAA7wB,KAAA,CAAAo4B,CAAA,EACAz0B,EAAA00B,oBAAA,IAEA10B,CAEA,EAEA,EA0qEAA,EAAAksB,EAAA4D,OAAA,CAAApmB,GACA1J,CAAA,EAIA","sources":["webpack://_N_E/./node_modules/three/examples/jsm/loaders/DRACOLoader.js","webpack://_N_E/./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js","webpack://_N_E/./node_modules/three/examples/jsm/loaders/GLTFLoader.js","webpack://_N_E/<anon>"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tColor,\n\tFileLoader,\n\tLoader,\n\tLinearSRGBColorSpace,\n\tSRGBColorSpace\n} from 'three';\n\nconst _taskCache = new WeakMap();\n\nclass DRACOLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.decoderPath = '';\n\t\tthis.decoderConfig = {};\n\t\tthis.decoderBinary = null;\n\t\tthis.decoderPending = null;\n\n\t\tthis.workerLimit = 4;\n\t\tthis.workerPool = [];\n\t\tthis.workerNextTaskID = 1;\n\t\tthis.workerSourceURL = '';\n\n\t\tthis.defaultAttributeIDs = {\n\t\t\tposition: 'POSITION',\n\t\t\tnormal: 'NORMAL',\n\t\t\tcolor: 'COLOR',\n\t\t\tuv: 'TEX_COORD'\n\t\t};\n\t\tthis.defaultAttributeTypes = {\n\t\t\tposition: 'Float32Array',\n\t\t\tnormal: 'Float32Array',\n\t\t\tcolor: 'Float32Array',\n\t\t\tuv: 'Float32Array'\n\t\t};\n\n\t}\n\n\tsetDecoderPath( path ) {\n\n\t\tthis.decoderPath = path;\n\n\t\treturn this;\n\n\t}\n\n\tsetDecoderConfig( config ) {\n\n\t\tthis.decoderConfig = config;\n\n\t\treturn this;\n\n\t}\n\n\tsetWorkerLimit( workerLimit ) {\n\n\t\tthis.workerLimit = workerLimit;\n\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst loader = new FileLoader( this.manager );\n\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, ( buffer ) => {\n\n\t\t\tthis.parse( buffer, onLoad, onError );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse ( buffer, onLoad, onError ) {\n\n\t\tthis.decodeDracoFile( buffer, onLoad, null, null, SRGBColorSpace ).catch( onError );\n\n\t}\n\n\tdecodeDracoFile( buffer, callback, attributeIDs, attributeTypes, vertexColorSpace = LinearSRGBColorSpace ) {\n\n\t\tconst taskConfig = {\n\t\t\tattributeIDs: attributeIDs || this.defaultAttributeIDs,\n\t\t\tattributeTypes: attributeTypes || this.defaultAttributeTypes,\n\t\t\tuseUniqueIDs: !! attributeIDs,\n\t\t\tvertexColorSpace: vertexColorSpace,\n\t\t};\n\n\t\treturn this.decodeGeometry( buffer, taskConfig ).then( callback );\n\n\t}\n\n\tdecodeGeometry( buffer, taskConfig ) {\n\n\t\tconst taskKey = JSON.stringify( taskConfig );\n\n\t\t// Check for an existing task using this buffer. A transferred buffer cannot be transferred\n\t\t// again from this thread.\n\t\tif ( _taskCache.has( buffer ) ) {\n\n\t\t\tconst cachedTask = _taskCache.get( buffer );\n\n\t\t\tif ( cachedTask.key === taskKey ) {\n\n\t\t\t\treturn cachedTask.promise;\n\n\t\t\t} else if ( buffer.byteLength === 0 ) {\n\n\t\t\t\t// Technically, it would be possible to wait for the previous task to complete,\n\t\t\t\t// transfer the buffer back, and decode again with the second configuration. That\n\t\t\t\t// is complex, and I don't know of any reason to decode a Draco buffer twice in\n\t\t\t\t// different ways, so this is left unimplemented.\n\t\t\t\tthrow new Error(\n\n\t\t\t\t\t'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +\n\t\t\t\t\t'settings. Buffer has already been transferred.'\n\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tlet worker;\n\t\tconst taskID = this.workerNextTaskID ++;\n\t\tconst taskCost = buffer.byteLength;\n\n\t\t// Obtain a worker and assign a task, and construct a geometry instance\n\t\t// when the task completes.\n\t\tconst geometryPending = this._getWorker( taskID, taskCost )\n\t\t\t.then( ( _worker ) => {\n\n\t\t\t\tworker = _worker;\n\n\t\t\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\t\t\tworker._callbacks[ taskID ] = { resolve, reject };\n\n\t\t\t\t\tworker.postMessage( { type: 'decode', id: taskID, taskConfig, buffer }, [ buffer ] );\n\n\t\t\t\t\t// this.debug();\n\n\t\t\t\t} );\n\n\t\t\t} )\n\t\t\t.then( ( message ) => this._createGeometry( message.geometry ) );\n\n\t\t// Remove task from the task list.\n\t\t// Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n\t\tgeometryPending\n\t\t\t.catch( () => true )\n\t\t\t.then( () => {\n\n\t\t\t\tif ( worker && taskID ) {\n\n\t\t\t\t\tthis._releaseTask( worker, taskID );\n\n\t\t\t\t\t// this.debug();\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t// Cache the task result.\n\t\t_taskCache.set( buffer, {\n\n\t\t\tkey: taskKey,\n\t\t\tpromise: geometryPending\n\n\t\t} );\n\n\t\treturn geometryPending;\n\n\t}\n\n\t_createGeometry( geometryData ) {\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tif ( geometryData.index ) {\n\n\t\t\tgeometry.setIndex( new BufferAttribute( geometryData.index.array, 1 ) );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < geometryData.attributes.length; i ++ ) {\n\n\t\t\tconst result = geometryData.attributes[ i ];\n\t\t\tconst name = result.name;\n\t\t\tconst array = result.array;\n\t\t\tconst itemSize = result.itemSize;\n\n\t\t\tconst attribute = new BufferAttribute( array, itemSize );\n\n\t\t\tif ( name === 'color' ) {\n\n\t\t\t\tthis._assignVertexColorSpace( attribute, result.vertexColorSpace );\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( name, attribute );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n\t_assignVertexColorSpace( attribute, inputColorSpace ) {\n\n\t\t// While .drc files do not specify colorspace, the only 'official' tooling\n\t\t// is PLY and OBJ converters, which use sRGB. We'll assume sRGB when a .drc\n\t\t// file is passed into .load() or .parse(). GLTFLoader uses internal APIs\n\t\t// to decode geometry, and vertex colors are already Linear-sRGB in there.\n\n\t\tif ( inputColorSpace !== SRGBColorSpace ) return;\n\n\t\tconst _color = new Color();\n\n\t\tfor ( let i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\t_color.fromBufferAttribute( attribute, i ).convertSRGBToLinear();\n\t\t\tattribute.setXYZ( i, _color.r, _color.g, _color.b );\n\n\t\t}\n\n\t}\n\n\t_loadLibrary( url, responseType ) {\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.decoderPath );\n\t\tloader.setResponseType( responseType );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tloader.load( url, resolve, undefined, reject );\n\n\t\t} );\n\n\t}\n\n\tpreload() {\n\n\t\tthis._initDecoder();\n\n\t\treturn this;\n\n\t}\n\n\t_initDecoder() {\n\n\t\tif ( this.decoderPending ) return this.decoderPending;\n\n\t\tconst useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';\n\t\tconst librariesPending = [];\n\n\t\tif ( useJS ) {\n\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_decoder.js', 'text' ) );\n\n\t\t} else {\n\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_wasm_wrapper.js', 'text' ) );\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_decoder.wasm', 'arraybuffer' ) );\n\n\t\t}\n\n\t\tthis.decoderPending = Promise.all( librariesPending )\n\t\t\t.then( ( libraries ) => {\n\n\t\t\t\tconst jsContent = libraries[ 0 ];\n\n\t\t\t\tif ( ! useJS ) {\n\n\t\t\t\t\tthis.decoderConfig.wasmBinary = libraries[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t\tconst fn = DRACOWorker.toString();\n\n\t\t\t\tconst body = [\n\t\t\t\t\t'/* draco decoder */',\n\t\t\t\t\tjsContent,\n\t\t\t\t\t'',\n\t\t\t\t\t'/* worker */',\n\t\t\t\t\tfn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) )\n\t\t\t\t].join( '\\n' );\n\n\t\t\t\tthis.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) );\n\n\t\t\t} );\n\n\t\treturn this.decoderPending;\n\n\t}\n\n\t_getWorker( taskID, taskCost ) {\n\n\t\treturn this._initDecoder().then( () => {\n\n\t\t\tif ( this.workerPool.length < this.workerLimit ) {\n\n\t\t\t\tconst worker = new Worker( this.workerSourceURL );\n\n\t\t\t\tworker._callbacks = {};\n\t\t\t\tworker._taskCosts = {};\n\t\t\t\tworker._taskLoad = 0;\n\n\t\t\t\tworker.postMessage( { type: 'init', decoderConfig: this.decoderConfig } );\n\n\t\t\t\tworker.onmessage = function ( e ) {\n\n\t\t\t\t\tconst message = e.data;\n\n\t\t\t\t\tswitch ( message.type ) {\n\n\t\t\t\t\t\tcase 'decode':\n\t\t\t\t\t\t\tworker._callbacks[ message.id ].resolve( message );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'error':\n\t\t\t\t\t\t\tworker._callbacks[ message.id ].reject( message );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"' );\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tthis.workerPool.push( worker );\n\n\t\t\t} else {\n\n\t\t\t\tthis.workerPool.sort( function ( a, b ) {\n\n\t\t\t\t\treturn a._taskLoad > b._taskLoad ? - 1 : 1;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst worker = this.workerPool[ this.workerPool.length - 1 ];\n\t\t\tworker._taskCosts[ taskID ] = taskCost;\n\t\t\tworker._taskLoad += taskCost;\n\t\t\treturn worker;\n\n\t\t} );\n\n\t}\n\n\t_releaseTask( worker, taskID ) {\n\n\t\tworker._taskLoad -= worker._taskCosts[ taskID ];\n\t\tdelete worker._callbacks[ taskID ];\n\t\tdelete worker._taskCosts[ taskID ];\n\n\t}\n\n\tdebug() {\n\n\t\tconsole.log( 'Task load: ', this.workerPool.map( ( worker ) => worker._taskLoad ) );\n\n\t}\n\n\tdispose() {\n\n\t\tfor ( let i = 0; i < this.workerPool.length; ++ i ) {\n\n\t\t\tthis.workerPool[ i ].terminate();\n\n\t\t}\n\n\t\tthis.workerPool.length = 0;\n\n\t\tif ( this.workerSourceURL !== '' ) {\n\n\t\t\tURL.revokeObjectURL( this.workerSourceURL );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\n/* WEB WORKER */\n\nfunction DRACOWorker() {\n\n\tlet decoderConfig;\n\tlet decoderPending;\n\n\tonmessage = function ( e ) {\n\n\t\tconst message = e.data;\n\n\t\tswitch ( message.type ) {\n\n\t\t\tcase 'init':\n\t\t\t\tdecoderConfig = message.decoderConfig;\n\t\t\t\tdecoderPending = new Promise( function ( resolve/*, reject*/ ) {\n\n\t\t\t\t\tdecoderConfig.onModuleLoaded = function ( draco ) {\n\n\t\t\t\t\t\t// Module is Promise-like. Wrap before resolving to avoid loop.\n\t\t\t\t\t\tresolve( { draco: draco } );\n\n\t\t\t\t\t};\n\n\t\t\t\t\tDracoDecoderModule( decoderConfig ); // eslint-disable-line no-undef\n\n\t\t\t\t} );\n\t\t\t\tbreak;\n\n\t\t\tcase 'decode':\n\t\t\t\tconst buffer = message.buffer;\n\t\t\t\tconst taskConfig = message.taskConfig;\n\t\t\t\tdecoderPending.then( ( module ) => {\n\n\t\t\t\t\tconst draco = module.draco;\n\t\t\t\t\tconst decoder = new draco.Decoder();\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tconst geometry = decodeGeometry( draco, decoder, new Int8Array( buffer ), taskConfig );\n\n\t\t\t\t\t\tconst buffers = geometry.attributes.map( ( attr ) => attr.array.buffer );\n\n\t\t\t\t\t\tif ( geometry.index ) buffers.push( geometry.index.array.buffer );\n\n\t\t\t\t\t\tself.postMessage( { type: 'decode', id: message.id, geometry }, buffers );\n\n\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\tconsole.error( error );\n\n\t\t\t\t\t\tself.postMessage( { type: 'error', id: message.id, error: error.message } );\n\n\t\t\t\t\t} finally {\n\n\t\t\t\t\t\tdraco.destroy( decoder );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t};\n\n\tfunction decodeGeometry( draco, decoder, array, taskConfig ) {\n\n\t\tconst attributeIDs = taskConfig.attributeIDs;\n\t\tconst attributeTypes = taskConfig.attributeTypes;\n\n\t\tlet dracoGeometry;\n\t\tlet decodingStatus;\n\n\t\tconst geometryType = decoder.GetEncodedGeometryType( array );\n\n\t\tif ( geometryType === draco.TRIANGULAR_MESH ) {\n\n\t\t\tdracoGeometry = new draco.Mesh();\n\t\t\tdecodingStatus = decoder.DecodeArrayToMesh( array, array.byteLength, dracoGeometry );\n\n\t\t} else if ( geometryType === draco.POINT_CLOUD ) {\n\n\t\t\tdracoGeometry = new draco.PointCloud();\n\t\t\tdecodingStatus = decoder.DecodeArrayToPointCloud( array, array.byteLength, dracoGeometry );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.DRACOLoader: Unexpected geometry type.' );\n\n\t\t}\n\n\t\tif ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {\n\n\t\t\tthrow new Error( 'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );\n\n\t\t}\n\n\t\tconst geometry = { index: null, attributes: [] };\n\n\t\t// Gather all vertex attributes.\n\t\tfor ( const attributeName in attributeIDs ) {\n\n\t\t\tconst attributeType = self[ attributeTypes[ attributeName ] ];\n\n\t\t\tlet attribute;\n\t\t\tlet attributeID;\n\n\t\t\t// A Draco file may be created with default vertex attributes, whose attribute IDs\n\t\t\t// are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n\t\t\t// a Draco file may contain a custom set of attributes, identified by known unique\n\t\t\t// IDs. glTF files always do the latter, and `.drc` files typically do the former.\n\t\t\tif ( taskConfig.useUniqueIDs ) {\n\n\t\t\t\tattributeID = attributeIDs[ attributeName ];\n\t\t\t\tattribute = decoder.GetAttributeByUniqueId( dracoGeometry, attributeID );\n\n\t\t\t} else {\n\n\t\t\t\tattributeID = decoder.GetAttributeId( dracoGeometry, draco[ attributeIDs[ attributeName ] ] );\n\n\t\t\t\tif ( attributeID === - 1 ) continue;\n\n\t\t\t\tattribute = decoder.GetAttribute( dracoGeometry, attributeID );\n\n\t\t\t}\n\n\t\t\tconst attributeResult = decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute );\n\n\t\t\tif ( attributeName === 'color' ) {\n\n\t\t\t\tattributeResult.vertexColorSpace = taskConfig.vertexColorSpace;\n\n\t\t\t}\n\n\t\t\tgeometry.attributes.push( attributeResult );\n\n\t\t}\n\n\t\t// Add index.\n\t\tif ( geometryType === draco.TRIANGULAR_MESH ) {\n\n\t\t\tgeometry.index = decodeIndex( draco, decoder, dracoGeometry );\n\n\t\t}\n\n\t\tdraco.destroy( dracoGeometry );\n\n\t\treturn geometry;\n\n\t}\n\n\tfunction decodeIndex( draco, decoder, dracoGeometry ) {\n\n\t\tconst numFaces = dracoGeometry.num_faces();\n\t\tconst numIndices = numFaces * 3;\n\t\tconst byteLength = numIndices * 4;\n\n\t\tconst ptr = draco._malloc( byteLength );\n\t\tdecoder.GetTrianglesUInt32Array( dracoGeometry, byteLength, ptr );\n\t\tconst index = new Uint32Array( draco.HEAPF32.buffer, ptr, numIndices ).slice();\n\t\tdraco._free( ptr );\n\n\t\treturn { array: index, itemSize: 1 };\n\n\t}\n\n\tfunction decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) {\n\n\t\tconst numComponents = attribute.num_components();\n\t\tconst numPoints = dracoGeometry.num_points();\n\t\tconst numValues = numPoints * numComponents;\n\t\tconst byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n\t\tconst dataType = getDracoDataType( draco, attributeType );\n\n\t\tconst ptr = draco._malloc( byteLength );\n\t\tdecoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, dataType, byteLength, ptr );\n\t\tconst array = new attributeType( draco.HEAPF32.buffer, ptr, numValues ).slice();\n\t\tdraco._free( ptr );\n\n\t\treturn {\n\t\t\tname: attributeName,\n\t\t\tarray: array,\n\t\t\titemSize: numComponents\n\t\t};\n\n\t}\n\n\tfunction getDracoDataType( draco, attributeType ) {\n\n\t\tswitch ( attributeType ) {\n\n\t\t\tcase Float32Array: return draco.DT_FLOAT32;\n\t\t\tcase Int8Array: return draco.DT_INT8;\n\t\t\tcase Int16Array: return draco.DT_INT16;\n\t\t\tcase Int32Array: return draco.DT_INT32;\n\t\t\tcase Uint8Array: return draco.DT_UINT8;\n\t\t\tcase Uint16Array: return draco.DT_UINT16;\n\t\t\tcase Uint32Array: return draco.DT_UINT32;\n\n\t\t}\n\n\t}\n\n}\n\nexport { DRACOLoader };\n","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInstancedBufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3,\n} from 'three';\n\nfunction computeTangents() { // @deprecated, r140\n\n\tthrow new Error( 'BufferGeometryUtils: computeTangents renamed to computeMikkTSpaceTangents.' );\n\n}\n\nfunction computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {\n\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\n\n\t}\n\n\tif ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.' );\n\n\t}\n\n\tfunction getAttributeArray( attribute ) {\n\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst dstArray = new Float32Array( attribute.getCount() * attribute.itemSize );\n\n\t\t\tfor ( let i = 0, j = 0; i < attribute.getCount(); i ++ ) {\n\n\t\t\t\tdstArray[ j ++ ] = attribute.getX( i );\n\t\t\t\tdstArray[ j ++ ] = attribute.getY( i );\n\n\t\t\t\tif ( attribute.itemSize > 2 ) {\n\n\t\t\t\t\tdstArray[ j ++ ] = attribute.getZ( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t\tif ( attribute.array instanceof Float32Array ) {\n\n\t\t\treturn attribute.array;\n\n\t\t}\n\n\t\treturn new Float32Array( attribute.array );\n\n\t}\n\n\t// MikkTSpace algorithm requires non-indexed input.\n\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n\t// Compute vertex tangents.\n\n\tconst tangents = MikkTSpace.generateTangents(\n\n\t\tgetAttributeArray( _geometry.attributes.position ),\n\t\tgetAttributeArray( _geometry.attributes.normal ),\n\t\tgetAttributeArray( _geometry.attributes.uv )\n\n\t);\n\n\t// Texture coordinate convention of glTF differs from the apparent\n\t// default of the MikkTSpace library; .w component must be flipped.\n\n\tif ( negateSign ) {\n\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\n\n\t\t\ttangents[ i ] *= - 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\n\n\tif ( geometry !== _geometry ) {\n\n\t\tgeometry.copy( _geometry );\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nfunction mergeBufferGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeBufferAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeBufferAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeBufferAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tarray.set( attributes[ i ].array, offset );\n\n\t\toffset += attributes[ i ].array.length;\n\n\t}\n\n\treturn new BufferAttribute( array, itemSize, normalized );\n\n}\n\n/**\n * @param {BufferAttribute}\n * @return {BufferAttribute}\n */\nexport function deepCloneAttribute( attribute ) {\n\n\tif ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) {\n\n\t\treturn deinterleaveAttribute( attribute );\n\n\t}\n\n\tif ( attribute.isInstancedBufferAttribute ) {\n\n\t\treturn new InstancedBufferAttribute().copy( attribute );\n\n\t}\n\n\treturn new BufferAttribute().copy( attribute );\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// returns a new, non-interleaved version of the provided attribute\nexport function deinterleaveAttribute( attribute ) {\n\n\tconst cons = attribute.data.array.constructor;\n\tconst count = attribute.count;\n\tconst itemSize = attribute.itemSize;\n\tconst normalized = attribute.normalized;\n\n\tconst array = new cons( count * itemSize );\n\tlet newAttribute;\n\tif ( attribute.isInstancedInterleavedBufferAttribute ) {\n\n\t\tnewAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );\n\n\t} else {\n\n\t\tnewAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t}\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tnewAttribute.setX( i, attribute.getX( i ) );\n\n\t\tif ( itemSize >= 2 ) {\n\n\t\t\tnewAttribute.setY( i, attribute.getY( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 3 ) {\n\n\t\t\tnewAttribute.setZ( i, attribute.getZ( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 4 ) {\n\n\t\t\tnewAttribute.setW( i, attribute.getW( i ) );\n\n\t\t}\n\n\t}\n\n\treturn newAttribute;\n\n}\n\n// deinterleaves all attributes on the geometry\nexport function deinterleaveGeometry( geometry ) {\n\n\tconst attributes = geometry.attributes;\n\tconst morphTargets = geometry.morphTargets;\n\tconst attrMap = new Map();\n\n\tfor ( const key in attributes ) {\n\n\t\tconst attr = attributes[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tattributes[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in morphTargets ) {\n\n\t\tconst attr = morphTargets[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tmorphTargets[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry}\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst tmpAttributes = {};\n\tconst tmpMorphAttributes = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t// Initialize the arrays, allocating space conservatively. Extra\n\t// space will be trimmed in the last step.\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst attr = geometry.attributes[ name ];\n\n\t\ttmpAttributes[ name ] = new BufferAttribute(\n\t\t\tnew attr.array.constructor( attr.count * attr.itemSize ),\n\t\t\tattr.itemSize,\n\t\t\tattr.normalized\n\t\t);\n\n\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\tif ( morphAttr ) {\n\n\t\t\ttmpMorphAttributes[ name ] = new BufferAttribute(\n\t\t\t\tnew morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize ),\n\t\t\t\tmorphAttr.itemSize,\n\t\t\t\tmorphAttr.normalized\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst decimalShift = Math.log10( 1 / tolerance );\n\tconst shiftMultiplier = Math.pow( 10, decimalShift );\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the temporary attributes\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newarray = tmpAttributes[ name ];\n\t\t\t\tconst newMorphArrays = tmpMorphAttributes[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tconst setterFunc = setters[ k ];\n\t\t\t\t\tnewarray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// generate result BufferGeometry\n\tconst result = geometry.clone();\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst tmpAttribute = tmpAttributes[ name ];\n\n\t\tresult.setAttribute( name, new BufferAttribute(\n\t\t\ttmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),\n\t\t\ttmpAttribute.itemSize,\n\t\t\ttmpAttribute.normalized,\n\t\t) );\n\n\t\tif ( ! ( name in tmpMorphAttributes ) ) continue;\n\n\t\tfor ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {\n\n\t\t\tconst tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];\n\n\t\t\tresult.morphAttributes[ name ][ j ] = new BufferAttribute(\n\t\t\t\ttmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),\n\t\t\t\ttmpMorphAttribute.itemSize,\n\t\t\t\ttmpMorphAttribute.normalized,\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.boneTransform( a, _vA );\n\t\t\tobject.boneTransform( b, _vB );\n\t\t\tobject.boneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\nfunction mergeGroups( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\n\t\treturn geometry;\n\n\t}\n\n\tlet groups = geometry.groups;\n\n\t// sort groups by material index\n\n\tgroups = groups.sort( ( a, b ) => {\n\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\n\n\t\treturn a.start - b.start;\n\n\t} );\n\n\t// create index for non-indexed geometries\n\n\tif ( geometry.getIndex() === null ) {\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst indices = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\tindices.push( i, i + 1, i + 2 );\n\n\t\t}\n\n\t\tgeometry.setIndex( indices );\n\n\t}\n\n\t// sort index\n\n\tconst index = geometry.getIndex();\n\n\tconst newIndices = [];\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst groupStart = group.start;\n\t\tconst groupLength = groupStart + group.count;\n\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\n\n\t\t\tnewIndices.push( index.getX( j ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dispose(); // Required to force buffer recreation\n\tgeometry.setIndex( newIndices );\n\n\t// update groups indices\n\n\tlet start = 0;\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tgroup.start = start;\n\t\tstart += group.count;\n\n\t}\n\n\t// merge groups\n\n\tlet currentGroup = groups[ 0 ];\n\n\tgeometry.groups = [ currentGroup ];\n\n\tfor ( let i = 1; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\n\n\t\t\tcurrentGroup.count += group.count;\n\n\t\t} else {\n\n\t\t\tcurrentGroup = group;\n\t\t\tgeometry.groups.push( currentGroup );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\n\n// Creates a new, non-indexed geometry with smooth normals everywhere except faces that meet at\n// an angle greater than the crease angle.\nfunction toCreasedNormals( geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {\n\n\tconst creaseDot = Math.cos( creaseAngle );\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\n\t// reusable vertors\n\tconst verts = [ new Vector3(), new Vector3(), new Vector3() ];\n\tconst tempVec1 = new Vector3();\n\tconst tempVec2 = new Vector3();\n\tconst tempNorm = new Vector3();\n\tconst tempNorm2 = new Vector3();\n\n\t// hashes a vector\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\t\treturn `${x},${y},${z}`;\n\n\t}\n\n\tconst resultGeometry = geometry.toNonIndexed();\n\tconst posAttr = resultGeometry.attributes.position;\n\tconst vertexMap = {};\n\n\t// find all the normals shared by commonly located vertices\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\t// add the normal to the map for all vertices\n\t\tconst normal = new Vector3().crossVectors( tempVec1, tempVec2 ).normalize();\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tif ( ! ( hash in vertexMap ) ) {\n\n\t\t\t\tvertexMap[ hash ] = [];\n\n\t\t\t}\n\n\t\t\tvertexMap[ hash ].push( normal );\n\n\t\t}\n\n\t}\n\n\t// average normals from all vertices that share a common location if they are within the\n\t// provided crease threshold\n\tconst normalArray = new Float32Array( posAttr.count * 3 );\n\tconst normAttr = new BufferAttribute( normalArray, 3, false );\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\t// get the face normal for this vertex\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\ttempNorm.crossVectors( tempVec1, tempVec2 ).normalize();\n\n\t\t// average all normals that meet the threshold and set the normal value\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tconst otherNormals = vertexMap[ hash ];\n\t\t\ttempNorm2.set( 0, 0, 0 );\n\n\t\t\tfor ( let k = 0, lk = otherNormals.length; k < lk; k ++ ) {\n\n\t\t\t\tconst otherNorm = otherNormals[ k ];\n\t\t\t\tif ( tempNorm.dot( otherNorm ) > creaseDot ) {\n\n\t\t\t\t\ttempNorm2.add( otherNorm );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttempNorm2.normalize();\n\t\t\tnormAttr.setXYZ( i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z );\n\n\t\t}\n\n\t}\n\n\tresultGeometry.setAttribute( 'normal', normAttr );\n\treturn resultGeometry;\n\n}\n\nexport {\n\tcomputeTangents,\n\tcomputeMikkTSpaceTangents,\n\tmergeBufferGeometries,\n\tmergeBufferAttributes,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n\tmergeGroups,\n\ttoCreasedNormals\n};\n","import {\n\tAnimationClip,\n\tBone,\n\tBox3,\n\tBufferAttribute,\n\tBufferGeometry,\n\tClampToEdgeWrapping,\n\tColor,\n\tDirectionalLight,\n\tDoubleSide,\n\tFileLoader,\n\tFrontSide,\n\tGroup,\n\tImageBitmapLoader,\n\tInstancedMesh,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tInterpolant,\n\tInterpolateDiscrete,\n\tInterpolateLinear,\n\tLine,\n\tLineBasicMaterial,\n\tLineLoop,\n\tLineSegments,\n\tLinearFilter,\n\tLinearMipmapLinearFilter,\n\tLinearMipmapNearestFilter,\n\tLoader,\n\tLoaderUtils,\n\tMaterial,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tMeshBasicMaterial,\n\tMeshPhysicalMaterial,\n\tMeshStandardMaterial,\n\tMirroredRepeatWrapping,\n\tNearestFilter,\n\tNearestMipmapLinearFilter,\n\tNearestMipmapNearestFilter,\n\tNumberKeyframeTrack,\n\tObject3D,\n\tOrthographicCamera,\n\tPerspectiveCamera,\n\tPointLight,\n\tPoints,\n\tPointsMaterial,\n\tPropertyBinding,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tRepeatWrapping,\n\tSkeleton,\n\tSkinnedMesh,\n\tSphere,\n\tSpotLight,\n\tTexture,\n\tTextureLoader,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tVector2,\n\tVector3,\n\tVectorKeyframeTrack,\n\tsRGBEncoding\n} from 'three';\nimport { toTrianglesDrawMode } from '../utils/BufferGeometryUtils.js';\n\nclass GLTFLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.dracoLoader = null;\n\t\tthis.ktx2Loader = null;\n\t\tthis.meshoptDecoder = null;\n\n\t\tthis.pluginCallbacks = [];\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsClearcoatExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureBasisUExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureWebPExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureAVIFExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsSheenExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsTransmissionExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsVolumeExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsIorExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsEmissiveStrengthExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsSpecularExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsIridescenceExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFLightsExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMeshoptCompression( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMeshGpuInstancing( parser );\n\n\t\t} );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tlet resourcePath;\n\n\t\tif ( this.resourcePath !== '' ) {\n\n\t\t\tresourcePath = this.resourcePath;\n\n\t\t} else if ( this.path !== '' ) {\n\n\t\t\tresourcePath = this.path;\n\n\t\t} else {\n\n\t\t\tresourcePath = LoaderUtils.extractUrlBase( url );\n\n\t\t}\n\n\t\t// Tells the LoadingManager to track an extra item, which resolves after\n\t\t// the model is fully loaded. This means the count of items loaded will\n\t\t// be incorrect, but ensures manager.onLoad() does not fire early.\n\t\tthis.manager.itemStart( url );\n\n\t\tconst _onError = function ( e ) {\n\n\t\t\tif ( onError ) {\n\n\t\t\t\tonError( e );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( e );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t};\n\n\t\tconst loader = new FileLoader( this.manager );\n\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( data ) {\n\n\t\t\ttry {\n\n\t\t\t\tscope.parse( data, resourcePath, function ( gltf ) {\n\n\t\t\t\t\tonLoad( gltf );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, _onError );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\t_onError( e );\n\n\t\t\t}\n\n\t\t}, onProgress, _onError );\n\n\t}\n\n\tsetDRACOLoader( dracoLoader ) {\n\n\t\tthis.dracoLoader = dracoLoader;\n\t\treturn this;\n\n\t}\n\n\tsetDDSLoader() {\n\n\t\tthrow new Error(\n\n\t\t\t'THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".'\n\n\t\t);\n\n\t}\n\n\tsetKTX2Loader( ktx2Loader ) {\n\n\t\tthis.ktx2Loader = ktx2Loader;\n\t\treturn this;\n\n\t}\n\n\tsetMeshoptDecoder( meshoptDecoder ) {\n\n\t\tthis.meshoptDecoder = meshoptDecoder;\n\t\treturn this;\n\n\t}\n\n\tregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\n\n\t\t\tthis.pluginCallbacks.push( callback );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tunregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\n\n\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tparse( data, path, onLoad, onError ) {\n\n\t\tlet json;\n\t\tconst extensions = {};\n\t\tconst plugins = {};\n\t\tconst textDecoder = new TextDecoder();\n\n\t\tif ( typeof data === 'string' ) {\n\n\t\t\tjson = JSON.parse( data );\n\n\t\t} else if ( data instanceof ArrayBuffer ) {\n\n\t\t\tconst magic = textDecoder.decode( new Uint8Array( data, 0, 4 ) );\n\n\t\t\tif ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\textensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );\n\n\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\tif ( onError ) onError( error );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tjson = JSON.parse( extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content );\n\n\t\t\t} else {\n\n\t\t\t\tjson = JSON.parse( textDecoder.decode( data ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tjson = data;\n\n\t\t}\n\n\t\tif ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {\n\n\t\t\tif ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst parser = new GLTFParser( json, {\n\n\t\t\tpath: path || this.resourcePath || '',\n\t\t\tcrossOrigin: this.crossOrigin,\n\t\t\trequestHeader: this.requestHeader,\n\t\t\tmanager: this.manager,\n\t\t\tktx2Loader: this.ktx2Loader,\n\t\t\tmeshoptDecoder: this.meshoptDecoder\n\n\t\t} );\n\n\t\tparser.fileLoader.setRequestHeader( this.requestHeader );\n\n\t\tfor ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {\n\n\t\t\tconst plugin = this.pluginCallbacks[ i ]( parser );\n\t\t\tplugins[ plugin.name ] = plugin;\n\n\t\t\t// Workaround to avoid determining as unknown extension\n\t\t\t// in addUnknownExtensionsToUserData().\n\t\t\t// Remove this workaround if we move all the existing\n\t\t\t// extension handlers to plugin system\n\t\t\textensions[ plugin.name ] = true;\n\n\t\t}\n\n\t\tif ( json.extensionsUsed ) {\n\n\t\t\tfor ( let i = 0; i < json.extensionsUsed.length; ++ i ) {\n\n\t\t\t\tconst extensionName = json.extensionsUsed[ i ];\n\t\t\t\tconst extensionsRequired = json.extensionsRequired || [];\n\n\t\t\t\tswitch ( extensionName ) {\n\n\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_UNLIT:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsUnlitExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFTextureTransformExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_MESH_QUANTIZATION:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMeshQuantizationExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tparser.setExtensions( extensions );\n\t\tparser.setPlugins( plugins );\n\t\tparser.parse( onLoad, onError );\n\n\t}\n\n\tparseAsync( data, path ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.parse( data, path, resolve, reject );\n\n\t\t} );\n\n\t}\n\n}\n\n/* GLTFREGISTRY */\n\nfunction GLTFRegistry() {\n\n\tlet objects = {};\n\n\treturn\t{\n\n\t\tget: function ( key ) {\n\n\t\t\treturn objects[ key ];\n\n\t\t},\n\n\t\tadd: function ( key, object ) {\n\n\t\t\tobjects[ key ] = object;\n\n\t\t},\n\n\t\tremove: function ( key ) {\n\n\t\t\tdelete objects[ key ];\n\n\t\t},\n\n\t\tremoveAll: function () {\n\n\t\t\tobjects = {};\n\n\t\t}\n\n\t};\n\n}\n\n/*********************************/\n/********** EXTENSIONS ***********/\n/*********************************/\n\nconst EXTENSIONS = {\n\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\n\tKHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n\tKHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n\tKHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n\tKHR_MATERIALS_IOR: 'KHR_materials_ior',\n\tKHR_MATERIALS_SHEEN: 'KHR_materials_sheen',\n\tKHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\n\tKHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n\tKHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',\n\tKHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n\tKHR_MATERIALS_VOLUME: 'KHR_materials_volume',\n\tKHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n\tKHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n\tKHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n\tKHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',\n\tEXT_TEXTURE_WEBP: 'EXT_texture_webp',\n\tEXT_TEXTURE_AVIF: 'EXT_texture_avif',\n\tEXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',\n\tEXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing'\n};\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightsExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n\n\t\t// Object3D instance caches\n\t\tthis.cache = { refs: {}, uses: {} };\n\n\t}\n\n\t_markDefs() {\n\n\t\tconst parser = this.parser;\n\t\tconst nodeDefs = this.parser.json.nodes || [];\n\n\t\tfor ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tconst nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.extensions\n\t\t\t\t\t&& nodeDef.extensions[ this.name ]\n\t\t\t\t\t&& nodeDef.extensions[ this.name ].light !== undefined ) {\n\n\t\t\t\tparser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_loadLight( lightIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst cacheKey = 'light:' + lightIndex;\n\t\tlet dependency = parser.cache.get( cacheKey );\n\n\t\tif ( dependency ) return dependency;\n\n\t\tconst json = parser.json;\n\t\tconst extensions = ( json.extensions && json.extensions[ this.name ] ) || {};\n\t\tconst lightDefs = extensions.lights || [];\n\t\tconst lightDef = lightDefs[ lightIndex ];\n\t\tlet lightNode;\n\n\t\tconst color = new Color( 0xffffff );\n\n\t\tif ( lightDef.color !== undefined ) color.fromArray( lightDef.color );\n\n\t\tconst range = lightDef.range !== undefined ? lightDef.range : 0;\n\n\t\tswitch ( lightDef.type ) {\n\n\t\t\tcase 'directional':\n\t\t\t\tlightNode = new DirectionalLight( color );\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tcase 'point':\n\t\t\t\tlightNode = new PointLight( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\tbreak;\n\n\t\t\tcase 'spot':\n\t\t\t\tlightNode = new SpotLight( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\t// Handle spotlight properties.\n\t\t\t\tlightDef.spot = lightDef.spot || {};\n\t\t\t\tlightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n\t\t\t\tlightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n\t\t\t\tlightNode.angle = lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );\n\n\t\t}\n\n\t\t// Some lights (e.g. spot) default to a position other than the origin. Reset the position\n\t\t// here, because node-level parsing will only override position if explicitly specified.\n\t\tlightNode.position.set( 0, 0, 0 );\n\n\t\tlightNode.decay = 2;\n\n\t\tassignExtrasToUserData( lightNode, lightDef );\n\n\t\tif ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;\n\n\t\tlightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );\n\n\t\tdependency = Promise.resolve( lightNode );\n\n\t\tparser.cache.add( cacheKey, dependency );\n\n\t\treturn dependency;\n\n\t}\n\n\tgetDependency( type, index ) {\n\n\t\tif ( type !== 'light' ) return;\n\n\t\treturn this._loadLight( index );\n\n\t}\n\n\tcreateNodeAttachment( nodeIndex ) {\n\n\t\tconst self = this;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\t\tconst lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};\n\t\tconst lightIndex = lightDef.light;\n\n\t\tif ( lightIndex === undefined ) return null;\n\n\t\treturn this._loadLight( lightIndex ).then( function ( light ) {\n\n\t\t\treturn parser._getNodeRef( self.cache, lightIndex, light );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n\n\t}\n\n\tgetMaterialType() {\n\n\t\treturn MeshBasicMaterial;\n\n\t}\n\n\textendParams( materialParams, materialDef, parser ) {\n\n\t\tconst pending = [];\n\n\t\tmaterialParams.color = new Color( 1.0, 1.0, 1.0 );\n\t\tmaterialParams.opacity = 1.0;\n\n\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness;\n\n\t\tif ( metallicRoughness ) {\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tconst array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, sRGBEncoding ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst emissiveStrength = materialDef.extensions[ this.name ].emissiveStrength;\n\n\t\tif ( emissiveStrength !== undefined ) {\n\n\t\t\tmaterialParams.emissiveIntensity = emissiveStrength;\n\n\t\t}\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.clearcoatFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoat = extension.clearcoatFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatNormalTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );\n\n\t\t\tif ( extension.clearcoatNormalTexture.scale !== undefined ) {\n\n\t\t\t\tconst scale = extension.clearcoatNormalTexture.scale;\n\n\t\t\t\tmaterialParams.clearcoatNormalScale = new Vector2( scale, scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.iridescenceFactor !== undefined ) {\n\n\t\t\tmaterialParams.iridescence = extension.iridescenceFactor;\n\n\t\t}\n\n\t\tif ( extension.iridescenceTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'iridescenceMap', extension.iridescenceTexture ) );\n\n\t\t}\n\n\t\tif ( extension.iridescenceIor !== undefined ) {\n\n\t\t\tmaterialParams.iridescenceIOR = extension.iridescenceIor;\n\n\t\t}\n\n\t\tif ( materialParams.iridescenceThicknessRange === undefined ) {\n\n\t\t\tmaterialParams.iridescenceThicknessRange = [ 100, 400 ];\n\n\t\t}\n\n\t\tif ( extension.iridescenceThicknessMinimum !== undefined ) {\n\n\t\t\tmaterialParams.iridescenceThicknessRange[ 0 ] = extension.iridescenceThicknessMinimum;\n\n\t\t}\n\n\t\tif ( extension.iridescenceThicknessMaximum !== undefined ) {\n\n\t\t\tmaterialParams.iridescenceThicknessRange[ 1 ] = extension.iridescenceThicknessMaximum;\n\n\t\t}\n\n\t\tif ( extension.iridescenceThicknessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n */\nclass GLTFMaterialsSheenExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tmaterialParams.sheenColor = new Color( 0, 0, 0 );\n\t\tmaterialParams.sheenRoughness = 0;\n\t\tmaterialParams.sheen = 1;\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.sheenColorFactor !== undefined ) {\n\n\t\t\tmaterialParams.sheenColor.fromArray( extension.sheenColorFactor );\n\n\t\t}\n\n\t\tif ( extension.sheenRoughnessFactor !== undefined ) {\n\n\t\t\tmaterialParams.sheenRoughness = extension.sheenRoughnessFactor;\n\n\t\t}\n\n\t\tif ( extension.sheenColorTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture, sRGBEncoding ) );\n\n\t\t}\n\n\t\tif ( extension.sheenRoughnessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n */\nclass GLTFMaterialsTransmissionExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.transmissionFactor !== undefined ) {\n\n\t\t\tmaterialParams.transmission = extension.transmissionFactor;\n\n\t\t}\n\n\t\tif ( extension.transmissionTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;\n\n\t\tif ( extension.thicknessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );\n\n\t\t}\n\n\t\tmaterialParams.attenuationDistance = extension.attenuationDistance || Infinity;\n\n\t\tconst colorArray = extension.attenuationColor || [ 1, 1, 1 ];\n\t\tmaterialParams.attenuationColor = new Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\nclass GLTFMaterialsIorExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_IOR;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\nclass GLTFMaterialsSpecularExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;\n\n\t\tif ( extension.specularTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );\n\n\t\t}\n\n\t\tconst colorArray = extension.specularColorFactor || [ 1, 1, 1 ];\n\t\tmaterialParams.specularColor = new Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );\n\n\t\tif ( extension.specularColorTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture, sRGBEncoding ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * BasisU Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n */\nclass GLTFTextureBasisUExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ this.name ];\n\t\tconst loader = parser.options.ktx2Loader;\n\n\t\tif ( ! loader ) {\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );\n\n\t\t\t} else {\n\n\t\t\t\t// Assumes that the extension is optional and that a fallback texture is present\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.loadTextureImage( textureIndex, extension.source, loader );\n\n\t}\n\n}\n\n/**\n * WebP Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n */\nclass GLTFTextureWebPExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n\t\tthis.isSupported = null;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst name = this.name;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ name ];\n\t\tconst source = json.images[ extension.source ];\n\n\t\tlet loader = parser.textureLoader;\n\t\tif ( source.uri ) {\n\n\t\t\tconst handler = parser.options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.detectSupport().then( function ( isSupported ) {\n\n\t\t\tif ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );\n\n\t\t\t}\n\n\t\t\t// Fall back to PNG or JPEG.\n\t\t\treturn parser.loadTexture( textureIndex );\n\n\t\t} );\n\n\t}\n\n\tdetectSupport() {\n\n\t\tif ( ! this.isSupported ) {\n\n\t\t\tthis.isSupported = new Promise( function ( resolve ) {\n\n\t\t\t\tconst image = new Image();\n\n\t\t\t\t// Lossy test image. Support for lossy images doesn't guarantee support for all\n\t\t\t\t// WebP images, unfortunately.\n\t\t\t\timage.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';\n\n\t\t\t\timage.onload = image.onerror = function () {\n\n\t\t\t\t\tresolve( image.height === 1 );\n\n\t\t\t\t};\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn this.isSupported;\n\n\t}\n\n}\n\n/**\n * AVIF Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif\n */\nclass GLTFTextureAVIFExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_AVIF;\n\t\tthis.isSupported = null;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst name = this.name;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ name ];\n\t\tconst source = json.images[ extension.source ];\n\n\t\tlet loader = parser.textureLoader;\n\t\tif ( source.uri ) {\n\n\t\t\tconst handler = parser.options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.detectSupport().then( function ( isSupported ) {\n\n\t\t\tif ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: AVIF required by asset but unsupported.' );\n\n\t\t\t}\n\n\t\t\t// Fall back to PNG or JPEG.\n\t\t\treturn parser.loadTexture( textureIndex );\n\n\t\t} );\n\n\t}\n\n\tdetectSupport() {\n\n\t\tif ( ! this.isSupported ) {\n\n\t\t\tthis.isSupported = new Promise( function ( resolve ) {\n\n\t\t\t\tconst image = new Image();\n\n\t\t\t\t// Lossy test image.\n\t\t\t\timage.src = 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=';\n\t\t\t\timage.onload = image.onerror = function () {\n\n\t\t\t\t\tresolve( image.height === 1 );\n\n\t\t\t\t};\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn this.isSupported;\n\n\t}\n\n}\n\n/**\n * meshopt BufferView Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n */\nclass GLTFMeshoptCompression {\n\n\tconstructor( parser ) {\n\n\t\tthis.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n\t\tthis.parser = parser;\n\n\t}\n\n\tloadBufferView( index ) {\n\n\t\tconst json = this.parser.json;\n\t\tconst bufferView = json.bufferViews[ index ];\n\n\t\tif ( bufferView.extensions && bufferView.extensions[ this.name ] ) {\n\n\t\t\tconst extensionDef = bufferView.extensions[ this.name ];\n\n\t\t\tconst buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );\n\t\t\tconst decoder = this.parser.options.meshoptDecoder;\n\n\t\t\tif ( ! decoder || ! decoder.supported ) {\n\n\t\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Assumes that the extension is optional and that fallback buffer data is present\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn buffer.then( function ( res ) {\n\n\t\t\t\tconst byteOffset = extensionDef.byteOffset || 0;\n\t\t\t\tconst byteLength = extensionDef.byteLength || 0;\n\n\t\t\t\tconst count = extensionDef.count;\n\t\t\t\tconst stride = extensionDef.byteStride;\n\n\t\t\t\tconst source = new Uint8Array( res, byteOffset, byteLength );\n\n\t\t\t\tif ( decoder.decodeGltfBufferAsync ) {\n\n\t\t\t\t\treturn decoder.decodeGltfBufferAsync( count, stride, source, extensionDef.mode, extensionDef.filter ).then( function ( res ) {\n\n\t\t\t\t\t\treturn res.buffer;\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync\n\t\t\t\t\treturn decoder.ready.then( function () {\n\n\t\t\t\t\t\tconst result = new ArrayBuffer( count * stride );\n\t\t\t\t\t\tdecoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );\n\t\t\t\t\t\treturn result;\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * GPU Instancing Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing\n *\n */\nclass GLTFMeshGpuInstancing {\n\n\tconstructor( parser ) {\n\n\t\tthis.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;\n\t\tthis.parser = parser;\n\n\t}\n\n\tcreateNodeMesh( nodeIndex ) {\n\n\t\tconst json = this.parser.json;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tif ( ! nodeDef.extensions || ! nodeDef.extensions[ this.name ] ||\n\t\t\tnodeDef.mesh === undefined ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst meshDef = json.meshes[ nodeDef.mesh ];\n\n\t\t// No Points or Lines + Instancing support yet\n\n\t\tfor ( const primitive of meshDef.primitives ) {\n\n\t\t\tif ( primitive.mode !== WEBGL_CONSTANTS.TRIANGLES &&\n\t\t\t\t primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&\n\t\t\t\t primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&\n\t\t\t\t primitive.mode !== undefined ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst extensionDef = nodeDef.extensions[ this.name ];\n\t\tconst attributesDef = extensionDef.attributes;\n\n\t\t// @TODO: Can we support InstancedMesh + SkinnedMesh?\n\n\t\tconst pending = [];\n\t\tconst attributes = {};\n\n\t\tfor ( const key in attributesDef ) {\n\n\t\t\tpending.push( this.parser.getDependency( 'accessor', attributesDef[ key ] ).then( accessor => {\n\n\t\t\t\tattributes[ key ] = accessor;\n\t\t\t\treturn attributes[ key ];\n\n\t\t\t} ) );\n\n\t\t}\n\n\t\tif ( pending.length < 1 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tpending.push( this.parser.createNodeMesh( nodeIndex ) );\n\n\t\treturn Promise.all( pending ).then( results => {\n\n\t\t\tconst nodeObject = results.pop();\n\t\t\tconst meshes = nodeObject.isGroup ? nodeObject.children : [ nodeObject ];\n\t\t\tconst count = results[ 0 ].count; // All attribute counts should be same\n\t\t\tconst instancedMeshes = [];\n\n\t\t\tfor ( const mesh of meshes ) {\n\n\t\t\t\t// Temporal variables\n\t\t\t\tconst m = new Matrix4();\n\t\t\t\tconst p = new Vector3();\n\t\t\t\tconst q = new Quaternion();\n\t\t\t\tconst s = new Vector3( 1, 1, 1 );\n\n\t\t\t\tconst instancedMesh = new InstancedMesh( mesh.geometry, mesh.material, count );\n\n\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\tif ( attributes.TRANSLATION ) {\n\n\t\t\t\t\t\tp.fromBufferAttribute( attributes.TRANSLATION, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.ROTATION ) {\n\n\t\t\t\t\t\tq.fromBufferAttribute( attributes.ROTATION, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.SCALE ) {\n\n\t\t\t\t\t\ts.fromBufferAttribute( attributes.SCALE, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tinstancedMesh.setMatrixAt( i, m.compose( p, q, s ) );\n\n\t\t\t\t}\n\n\t\t\t\t// Add instance attributes to the geometry, excluding TRS.\n\t\t\t\tfor ( const attributeName in attributes ) {\n\n\t\t\t\t\tif ( attributeName !== 'TRANSLATION' &&\n\t\t\t\t\t\t attributeName !== 'ROTATION' &&\n\t\t\t\t\t\t attributeName !== 'SCALE' ) {\n\n\t\t\t\t\t\tmesh.geometry.setAttribute( attributeName, attributes[ attributeName ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Just in case\n\t\t\t\tObject3D.prototype.copy.call( instancedMesh, mesh );\n\n\t\t\t\t// https://github.com/mrdoob/three.js/issues/18334\n\t\t\t\tinstancedMesh.frustumCulled = false;\n\t\t\t\tthis.parser.assignFinalMaterial( instancedMesh );\n\n\t\t\t\tinstancedMeshes.push( instancedMesh );\n\n\t\t\t}\n\n\t\t\tif ( nodeObject.isGroup ) {\n\n\t\t\t\tnodeObject.clear();\n\n\t\t\t\tnodeObject.add( ... instancedMeshes );\n\n\t\t\t\treturn nodeObject;\n\n\t\t\t}\n\n\t\t\treturn instancedMeshes[ 0 ];\n\n\t\t} );\n\n\t}\n\n}\n\n/* BINARY EXTENSION */\nconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\n\nclass GLTFBinaryExtension {\n\n\tconstructor( data ) {\n\n\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\n\t\tthis.content = null;\n\t\tthis.body = null;\n\n\t\tconst headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );\n\t\tconst textDecoder = new TextDecoder();\n\n\t\tthis.header = {\n\t\t\tmagic: textDecoder.decode( new Uint8Array( data.slice( 0, 4 ) ) ),\n\t\t\tversion: headerView.getUint32( 4, true ),\n\t\t\tlength: headerView.getUint32( 8, true )\n\t\t};\n\n\t\tif ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );\n\n\t\t} else if ( this.header.version < 2.0 ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );\n\n\t\t}\n\n\t\tconst chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n\t\tconst chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );\n\t\tlet chunkIndex = 0;\n\n\t\twhile ( chunkIndex < chunkContentsLength ) {\n\n\t\t\tconst chunkLength = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tconst chunkType = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tif ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {\n\n\t\t\t\tconst contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );\n\t\t\t\tthis.content = textDecoder.decode( contentArray );\n\n\t\t\t} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {\n\n\t\t\t\tconst byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n\t\t\t\tthis.body = data.slice( byteOffset, byteOffset + chunkLength );\n\n\t\t\t}\n\n\t\t\t// Clients must ignore chunks with unknown types.\n\n\t\t\tchunkIndex += chunkLength;\n\n\t\t}\n\n\t\tif ( this.content === null ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: JSON content not found.' );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * DRACO Mesh Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n */\nclass GLTFDracoMeshCompressionExtension {\n\n\tconstructor( json, dracoLoader ) {\n\n\t\tif ( ! dracoLoader ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );\n\n\t\t}\n\n\t\tthis.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n\t\tthis.json = json;\n\t\tthis.dracoLoader = dracoLoader;\n\t\tthis.dracoLoader.preload();\n\n\t}\n\n\tdecodePrimitive( primitive, parser ) {\n\n\t\tconst json = this.json;\n\t\tconst dracoLoader = this.dracoLoader;\n\t\tconst bufferViewIndex = primitive.extensions[ this.name ].bufferView;\n\t\tconst gltfAttributeMap = primitive.extensions[ this.name ].attributes;\n\t\tconst threeAttributeMap = {};\n\t\tconst attributeNormalizedMap = {};\n\t\tconst attributeTypeMap = {};\n\n\t\tfor ( const attributeName in gltfAttributeMap ) {\n\n\t\t\tconst threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tthreeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];\n\n\t\t}\n\n\t\tfor ( const attributeName in primitive.attributes ) {\n\n\t\t\tconst threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tif ( gltfAttributeMap[ attributeName ] !== undefined ) {\n\n\t\t\t\tconst accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];\n\t\t\t\tconst componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t\tattributeTypeMap[ threeAttributeName ] = componentType.name;\n\t\t\t\tattributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {\n\n\t\t\treturn new Promise( function ( resolve ) {\n\n\t\t\t\tdracoLoader.decodeDracoFile( bufferView, function ( geometry ) {\n\n\t\t\t\t\tfor ( const attributeName in geometry.attributes ) {\n\n\t\t\t\t\t\tconst attribute = geometry.attributes[ attributeName ];\n\t\t\t\t\t\tconst normalized = attributeNormalizedMap[ attributeName ];\n\n\t\t\t\t\t\tif ( normalized !== undefined ) attribute.normalized = normalized;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve( geometry );\n\n\t\t\t\t}, threeAttributeMap, attributeTypeMap );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n * Texture Transform Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n */\nclass GLTFTextureTransformExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n\n\t}\n\n\textendTexture( texture, transform ) {\n\n\t\tif ( transform.texCoord !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.' );\n\n\t\t}\n\n\t\tif ( transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined ) {\n\n\t\t\t// See https://github.com/mrdoob/three.js/issues/21819.\n\t\t\treturn texture;\n\n\t\t}\n\n\t\ttexture = texture.clone();\n\n\t\tif ( transform.offset !== undefined ) {\n\n\t\t\ttexture.offset.fromArray( transform.offset );\n\n\t\t}\n\n\t\tif ( transform.rotation !== undefined ) {\n\n\t\t\ttexture.rotation = transform.rotation;\n\n\t\t}\n\n\t\tif ( transform.scale !== undefined ) {\n\n\t\t\ttexture.repeat.fromArray( transform.scale );\n\n\t\t}\n\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t}\n\n}\n\n/**\n * Mesh Quantization Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n */\nclass GLTFMeshQuantizationExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n\n\t}\n\n}\n\n/*********************************/\n/********** INTERPOLATION ********/\n/*********************************/\n\n// Spline Interpolation\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\nclass GLTFCubicSplineInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tcopySampleValue_( index ) {\n\n\t\t// Copies a sample value to the result buffer. See description of glTF\n\t\t// CUBICSPLINE values layout in interpolate_() function below.\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tvalueSize = this.valueSize,\n\t\t\toffset = index * valueSize * 3 + valueSize;\n\n\t\tfor ( let i = 0; i !== valueSize; i ++ ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer;\n\t\tconst values = this.sampleValues;\n\t\tconst stride = this.valueSize;\n\n\t\tconst stride2 = stride * 2;\n\t\tconst stride3 = stride * 3;\n\n\t\tconst td = t1 - t0;\n\n\t\tconst p = ( t - t0 ) / td;\n\t\tconst pp = p * p;\n\t\tconst ppp = pp * p;\n\n\t\tconst offset1 = i1 * stride3;\n\t\tconst offset0 = offset1 - stride3;\n\n\t\tconst s2 = - 2 * ppp + 3 * pp;\n\t\tconst s3 = ppp - pp;\n\t\tconst s0 = 1 - s2;\n\t\tconst s1 = s3 - pp + p;\n\n\t\t// Layout of keyframe output values for CUBICSPLINE animations:\n\t\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\t\tfor ( let i = 0; i !== stride; i ++ ) {\n\n\t\t\tconst p0 = values[ offset0 + i + stride ]; // splineVertex_k\n\t\t\tconst m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)\n\t\t\tconst p1 = values[ offset1 + i + stride ]; // splineVertex_k+1\n\t\t\tconst m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n\t\t\tresult[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\nconst _q = new Quaternion();\n\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = super.interpolate_( i1, t0, t, t1 );\n\n\t\t_q.fromArray( result ).normalize().toArray( result );\n\n\t\treturn result;\n\n\t}\n\n}\n\n\n/*********************************/\n/********** INTERNALS ************/\n/*********************************/\n\n/* CONSTANTS */\n\nconst WEBGL_CONSTANTS = {\n\tFLOAT: 5126,\n\t//FLOAT_MAT2: 35674,\n\tFLOAT_MAT3: 35675,\n\tFLOAT_MAT4: 35676,\n\tFLOAT_VEC2: 35664,\n\tFLOAT_VEC3: 35665,\n\tFLOAT_VEC4: 35666,\n\tLINEAR: 9729,\n\tREPEAT: 10497,\n\tSAMPLER_2D: 35678,\n\tPOINTS: 0,\n\tLINES: 1,\n\tLINE_LOOP: 2,\n\tLINE_STRIP: 3,\n\tTRIANGLES: 4,\n\tTRIANGLE_STRIP: 5,\n\tTRIANGLE_FAN: 6,\n\tUNSIGNED_BYTE: 5121,\n\tUNSIGNED_SHORT: 5123\n};\n\nconst WEBGL_COMPONENT_TYPES = {\n\t5120: Int8Array,\n\t5121: Uint8Array,\n\t5122: Int16Array,\n\t5123: Uint16Array,\n\t5125: Uint32Array,\n\t5126: Float32Array\n};\n\nconst WEBGL_FILTERS = {\n\t9728: NearestFilter,\n\t9729: LinearFilter,\n\t9984: NearestMipmapNearestFilter,\n\t9985: LinearMipmapNearestFilter,\n\t9986: NearestMipmapLinearFilter,\n\t9987: LinearMipmapLinearFilter\n};\n\nconst WEBGL_WRAPPINGS = {\n\t33071: ClampToEdgeWrapping,\n\t33648: MirroredRepeatWrapping,\n\t10497: RepeatWrapping\n};\n\nconst WEBGL_TYPE_SIZES = {\n\t'SCALAR': 1,\n\t'VEC2': 2,\n\t'VEC3': 3,\n\t'VEC4': 4,\n\t'MAT2': 4,\n\t'MAT3': 9,\n\t'MAT4': 16\n};\n\nconst ATTRIBUTES = {\n\tPOSITION: 'position',\n\tNORMAL: 'normal',\n\tTANGENT: 'tangent',\n\tTEXCOORD_0: 'uv',\n\tTEXCOORD_1: 'uv2',\n\tCOLOR_0: 'color',\n\tWEIGHTS_0: 'skinWeight',\n\tJOINTS_0: 'skinIndex',\n};\n\nconst PATH_PROPERTIES = {\n\tscale: 'scale',\n\ttranslation: 'position',\n\trotation: 'quaternion',\n\tweights: 'morphTargetInfluences'\n};\n\nconst INTERPOLATION = {\n\tCUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n\t\t                        // keyframe track will be initialized with a default interpolation type, then modified.\n\tLINEAR: InterpolateLinear,\n\tSTEP: InterpolateDiscrete\n};\n\nconst ALPHA_MODES = {\n\tOPAQUE: 'OPAQUE',\n\tMASK: 'MASK',\n\tBLEND: 'BLEND'\n};\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n */\nfunction createDefaultMaterial( cache ) {\n\n\tif ( cache[ 'DefaultMaterial' ] === undefined ) {\n\n\t\tcache[ 'DefaultMaterial' ] = new MeshStandardMaterial( {\n\t\t\tcolor: 0xFFFFFF,\n\t\t\temissive: 0x000000,\n\t\t\tmetalness: 1,\n\t\t\troughness: 1,\n\t\t\ttransparent: false,\n\t\t\tdepthTest: true,\n\t\t\tside: FrontSide\n\t\t} );\n\n\t}\n\n\treturn cache[ 'DefaultMaterial' ];\n\n}\n\nfunction addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {\n\n\t// Add unknown glTF extensions to an object's userData.\n\n\tfor ( const name in objectDef.extensions ) {\n\n\t\tif ( knownExtensions[ name ] === undefined ) {\n\n\t\t\tobject.userData.gltfExtensions = object.userData.gltfExtensions || {};\n\t\t\tobject.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {Object3D|Material|BufferGeometry} object\n * @param {GLTF.definition} gltfDef\n */\nfunction assignExtrasToUserData( object, gltfDef ) {\n\n\tif ( gltfDef.extras !== undefined ) {\n\n\t\tif ( typeof gltfDef.extras === 'object' ) {\n\n\t\t\tObject.assign( object.userData, gltfDef.extras );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n *\n * @param {BufferGeometry} geometry\n * @param {Array<GLTF.Target>} targets\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addMorphTargets( geometry, targets, parser ) {\n\n\tlet hasMorphPosition = false;\n\tlet hasMorphNormal = false;\n\tlet hasMorphColor = false;\n\n\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\tconst target = targets[ i ];\n\n\t\tif ( target.POSITION !== undefined ) hasMorphPosition = true;\n\t\tif ( target.NORMAL !== undefined ) hasMorphNormal = true;\n\t\tif ( target.COLOR_0 !== undefined ) hasMorphColor = true;\n\n\t\tif ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break;\n\n\t}\n\n\tif ( ! hasMorphPosition && ! hasMorphNormal && ! hasMorphColor ) return Promise.resolve( geometry );\n\n\tconst pendingPositionAccessors = [];\n\tconst pendingNormalAccessors = [];\n\tconst pendingColorAccessors = [];\n\n\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\tconst target = targets[ i ];\n\n\t\tif ( hasMorphPosition ) {\n\n\t\t\tconst pendingAccessor = target.POSITION !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.POSITION )\n\t\t\t\t: geometry.attributes.position;\n\n\t\t\tpendingPositionAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t\tif ( hasMorphNormal ) {\n\n\t\t\tconst pendingAccessor = target.NORMAL !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.NORMAL )\n\t\t\t\t: geometry.attributes.normal;\n\n\t\t\tpendingNormalAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t\tif ( hasMorphColor ) {\n\n\t\t\tconst pendingAccessor = target.COLOR_0 !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.COLOR_0 )\n\t\t\t\t: geometry.attributes.color;\n\n\t\t\tpendingColorAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t}\n\n\treturn Promise.all( [\n\t\tPromise.all( pendingPositionAccessors ),\n\t\tPromise.all( pendingNormalAccessors ),\n\t\tPromise.all( pendingColorAccessors )\n\t] ).then( function ( accessors ) {\n\n\t\tconst morphPositions = accessors[ 0 ];\n\t\tconst morphNormals = accessors[ 1 ];\n\t\tconst morphColors = accessors[ 2 ];\n\n\t\tif ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;\n\t\tif ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;\n\t\tif ( hasMorphColor ) geometry.morphAttributes.color = morphColors;\n\t\tgeometry.morphTargetsRelative = true;\n\n\t\treturn geometry;\n\n\t} );\n\n}\n\n/**\n * @param {Mesh} mesh\n * @param {GLTF.Mesh} meshDef\n */\nfunction updateMorphTargets( mesh, meshDef ) {\n\n\tmesh.updateMorphTargets();\n\n\tif ( meshDef.weights !== undefined ) {\n\n\t\tfor ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {\n\n\t\t\tmesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];\n\n\t\t}\n\n\t}\n\n\t// .extras has user-defined data, so check that .extras.targetNames is an array.\n\tif ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {\n\n\t\tconst targetNames = meshDef.extras.targetNames;\n\n\t\tif ( mesh.morphTargetInfluences.length === targetNames.length ) {\n\n\t\t\tmesh.morphTargetDictionary = {};\n\n\t\t\tfor ( let i = 0, il = targetNames.length; i < il; i ++ ) {\n\n\t\t\t\tmesh.morphTargetDictionary[ targetNames[ i ] ] = i;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );\n\n\t\t}\n\n\t}\n\n}\n\nfunction createPrimitiveKey( primitiveDef ) {\n\n\tconst dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];\n\tlet geometryKey;\n\n\tif ( dracoExtension ) {\n\n\t\tgeometryKey = 'draco:' + dracoExtension.bufferView\n\t\t\t\t+ ':' + dracoExtension.indices\n\t\t\t\t+ ':' + createAttributesKey( dracoExtension.attributes );\n\n\t} else {\n\n\t\tgeometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;\n\n\t}\n\n\treturn geometryKey;\n\n}\n\nfunction createAttributesKey( attributes ) {\n\n\tlet attributesKey = '';\n\n\tconst keys = Object.keys( attributes ).sort();\n\n\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\tattributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';\n\n\t}\n\n\treturn attributesKey;\n\n}\n\nfunction getNormalizedComponentScale( constructor ) {\n\n\t// Reference:\n\t// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n\n\tswitch ( constructor ) {\n\n\t\tcase Int8Array:\n\t\t\treturn 1 / 127;\n\n\t\tcase Uint8Array:\n\t\t\treturn 1 / 255;\n\n\t\tcase Int16Array:\n\t\t\treturn 1 / 32767;\n\n\t\tcase Uint16Array:\n\t\t\treturn 1 / 65535;\n\n\t\tdefault:\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );\n\n\t}\n\n}\n\nfunction getImageURIMimeType( uri ) {\n\n\tif ( uri.search( /\\.jpe?g($|\\?)/i ) > 0 || uri.search( /^data\\:image\\/jpeg/ ) === 0 ) return 'image/jpeg';\n\tif ( uri.search( /\\.webp($|\\?)/i ) > 0 || uri.search( /^data\\:image\\/webp/ ) === 0 ) return 'image/webp';\n\n\treturn 'image/png';\n\n}\n\nconst _identityMatrix = new Matrix4();\n\n/* GLTF PARSER */\n\nclass GLTFParser {\n\n\tconstructor( json = {}, options = {} ) {\n\n\t\tthis.json = json;\n\t\tthis.extensions = {};\n\t\tthis.plugins = {};\n\t\tthis.options = options;\n\n\t\t// loader object cache\n\t\tthis.cache = new GLTFRegistry();\n\n\t\t// associations between Three.js objects and glTF elements\n\t\tthis.associations = new Map();\n\n\t\t// BufferGeometry caching\n\t\tthis.primitiveCache = {};\n\n\t\t// Node cache\n\t\tthis.nodeCache = {};\n\n\t\t// Object3D instance caches\n\t\tthis.meshCache = { refs: {}, uses: {} };\n\t\tthis.cameraCache = { refs: {}, uses: {} };\n\t\tthis.lightCache = { refs: {}, uses: {} };\n\n\t\tthis.sourceCache = {};\n\t\tthis.textureCache = {};\n\n\t\t// Track node names, to ensure no duplicates\n\t\tthis.nodeNamesUsed = {};\n\n\t\t// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n\t\t// expensive work of uploading a texture to the GPU off the main thread.\n\n\t\tlet isSafari = false;\n\t\tlet isFirefox = false;\n\t\tlet firefoxVersion = - 1;\n\n\t\tif ( typeof navigator !== 'undefined' ) {\n\n\t\t\tisSafari = /^((?!chrome|android).)*safari/i.test( navigator.userAgent ) === true;\n\t\t\tisFirefox = navigator.userAgent.indexOf( 'Firefox' ) > - 1;\n\t\t\tfirefoxVersion = isFirefox ? navigator.userAgent.match( /Firefox\\/([0-9]+)\\./ )[ 1 ] : - 1;\n\n\t\t}\n\n\t\tif ( typeof createImageBitmap === 'undefined' || isSafari || ( isFirefox && firefoxVersion < 98 ) ) {\n\n\t\t\tthis.textureLoader = new TextureLoader( this.options.manager );\n\n\t\t} else {\n\n\t\t\tthis.textureLoader = new ImageBitmapLoader( this.options.manager );\n\n\t\t}\n\n\t\tthis.textureLoader.setCrossOrigin( this.options.crossOrigin );\n\t\tthis.textureLoader.setRequestHeader( this.options.requestHeader );\n\n\t\tthis.fileLoader = new FileLoader( this.options.manager );\n\t\tthis.fileLoader.setResponseType( 'arraybuffer' );\n\n\t\tif ( this.options.crossOrigin === 'use-credentials' ) {\n\n\t\t\tthis.fileLoader.setWithCredentials( true );\n\n\t\t}\n\n\t}\n\n\tsetExtensions( extensions ) {\n\n\t\tthis.extensions = extensions;\n\n\t}\n\n\tsetPlugins( plugins ) {\n\n\t\tthis.plugins = plugins;\n\n\t}\n\n\tparse( onLoad, onError ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\n\t\t// Clear the loader cache\n\t\tthis.cache.removeAll();\n\t\tthis.nodeCache = {};\n\n\t\t// Mark the special nodes/meshes in json for efficient parse\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\treturn ext._markDefs && ext._markDefs();\n\n\t\t} );\n\n\t\tPromise.all( this._invokeAll( function ( ext ) {\n\n\t\t\treturn ext.beforeRoot && ext.beforeRoot();\n\n\t\t} ) ).then( function () {\n\n\t\t\treturn Promise.all( [\n\n\t\t\t\tparser.getDependencies( 'scene' ),\n\t\t\t\tparser.getDependencies( 'animation' ),\n\t\t\t\tparser.getDependencies( 'camera' ),\n\n\t\t\t] );\n\n\t\t} ).then( function ( dependencies ) {\n\n\t\t\tconst result = {\n\t\t\t\tscene: dependencies[ 0 ][ json.scene || 0 ],\n\t\t\t\tscenes: dependencies[ 0 ],\n\t\t\t\tanimations: dependencies[ 1 ],\n\t\t\t\tcameras: dependencies[ 2 ],\n\t\t\t\tasset: json.asset,\n\t\t\t\tparser: parser,\n\t\t\t\tuserData: {}\n\t\t\t};\n\n\t\t\taddUnknownExtensionsToUserData( extensions, result, json );\n\n\t\t\tassignExtrasToUserData( result, json );\n\n\t\t\tPromise.all( parser._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.afterRoot && ext.afterRoot( result );\n\n\t\t\t} ) ).then( function () {\n\n\t\t\t\tonLoad( result );\n\n\t\t\t} );\n\n\t\t} ).catch( onError );\n\n\t}\n\n\t/**\n\t * Marks the special nodes/meshes in json for efficient parse.\n\t */\n\t_markDefs() {\n\n\t\tconst nodeDefs = this.json.nodes || [];\n\t\tconst skinDefs = this.json.skins || [];\n\t\tconst meshDefs = this.json.meshes || [];\n\n\t\t// Nothing in the node definition indicates whether it is a Bone or an\n\t\t// Object3D. Use the skins' joint references to mark bones.\n\t\tfor ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {\n\n\t\t\tconst joints = skinDefs[ skinIndex ].joints;\n\n\t\t\tfor ( let i = 0, il = joints.length; i < il; i ++ ) {\n\n\t\t\t\tnodeDefs[ joints[ i ] ].isBone = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Iterate over all nodes, marking references to shared resources,\n\t\t// as well as skeleton joints.\n\t\tfor ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tconst nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.mesh !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.meshCache, nodeDef.mesh );\n\n\t\t\t\t// Nothing in the mesh definition indicates whether it is\n\t\t\t\t// a SkinnedMesh or Mesh. Use the node's mesh reference\n\t\t\t\t// to mark SkinnedMesh if node has skin.\n\t\t\t\tif ( nodeDef.skin !== undefined ) {\n\n\t\t\t\t\tmeshDefs[ nodeDef.mesh ].isSkinnedMesh = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.cameraCache, nodeDef.camera );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Counts references to shared node / Object3D resources. These resources\n\t * can be reused, or \"instantiated\", at multiple nodes in the scene\n\t * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n\t * be marked. Non-scenegraph resources (like Materials, Geometries, and\n\t * Textures) can be reused directly and are not marked here.\n\t *\n\t * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\t */\n\t_addNodeRef( cache, index ) {\n\n\t\tif ( index === undefined ) return;\n\n\t\tif ( cache.refs[ index ] === undefined ) {\n\n\t\t\tcache.refs[ index ] = cache.uses[ index ] = 0;\n\n\t\t}\n\n\t\tcache.refs[ index ] ++;\n\n\t}\n\n\t/** Returns a reference to a shared resource, cloning it if necessary. */\n\t_getNodeRef( cache, index, object ) {\n\n\t\tif ( cache.refs[ index ] <= 1 ) return object;\n\n\t\tconst ref = object.clone();\n\n\t\t// Propagates mappings to the cloned object, prevents mappings on the\n\t\t// original object from being lost.\n\t\tconst updateMappings = ( original, clone ) => {\n\n\t\t\tconst mappings = this.associations.get( original );\n\t\t\tif ( mappings != null ) {\n\n\t\t\t\tthis.associations.set( clone, mappings );\n\n\t\t\t}\n\n\t\t\tfor ( const [ i, child ] of original.children.entries() ) {\n\n\t\t\t\tupdateMappings( child, clone.children[ i ] );\n\n\t\t\t}\n\n\t\t};\n\n\t\tupdateMappings( object, ref );\n\n\t\tref.name += '_instance_' + ( cache.uses[ index ] ++ );\n\n\t\treturn ref;\n\n\t}\n\n\t_invokeOne( func ) {\n\n\t\tconst extensions = Object.values( this.plugins );\n\t\textensions.push( this );\n\n\t\tfor ( let i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tconst result = func( extensions[ i ] );\n\n\t\t\tif ( result ) return result;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t_invokeAll( func ) {\n\n\t\tconst extensions = Object.values( this.plugins );\n\t\textensions.unshift( this );\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tconst result = func( extensions[ i ] );\n\n\t\t\tif ( result ) pending.push( result );\n\n\t\t}\n\n\t\treturn pending;\n\n\t}\n\n\t/**\n\t * Requests the specified dependency asynchronously, with caching.\n\t * @param {string} type\n\t * @param {number} index\n\t * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n\t */\n\tgetDependency( type, index ) {\n\n\t\tconst cacheKey = type + ':' + index;\n\t\tlet dependency = this.cache.get( cacheKey );\n\n\t\tif ( ! dependency ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'scene':\n\t\t\t\t\tdependency = this.loadScene( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'node':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadNode && ext.loadNode( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mesh':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMesh && ext.loadMesh( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'accessor':\n\t\t\t\t\tdependency = this.loadAccessor( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bufferView':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadBufferView && ext.loadBufferView( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'buffer':\n\t\t\t\t\tdependency = this.loadBuffer( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'material':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMaterial && ext.loadMaterial( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'texture':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadTexture && ext.loadTexture( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'skin':\n\t\t\t\t\tdependency = this.loadSkin( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'animation':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadAnimation && ext.loadAnimation( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'camera':\n\t\t\t\t\tdependency = this.loadCamera( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext != this && ext.getDependency && ext.getDependency( type, index );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tif ( ! dependency ) {\n\n\t\t\t\t\t\tthrow new Error( 'Unknown type: ' + type );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tthis.cache.add( cacheKey, dependency );\n\n\t\t}\n\n\t\treturn dependency;\n\n\t}\n\n\t/**\n\t * Requests all dependencies of the specified type asynchronously, with caching.\n\t * @param {string} type\n\t * @return {Promise<Array<Object>>}\n\t */\n\tgetDependencies( type ) {\n\n\t\tlet dependencies = this.cache.get( type );\n\n\t\tif ( ! dependencies ) {\n\n\t\t\tconst parser = this;\n\t\t\tconst defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];\n\n\t\t\tdependencies = Promise.all( defs.map( function ( def, index ) {\n\n\t\t\t\treturn parser.getDependency( type, index );\n\n\t\t\t} ) );\n\n\t\t\tthis.cache.add( type, dependencies );\n\n\t\t}\n\n\t\treturn dependencies;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tloadBuffer( bufferIndex ) {\n\n\t\tconst bufferDef = this.json.buffers[ bufferIndex ];\n\t\tconst loader = this.fileLoader;\n\n\t\tif ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );\n\n\t\t}\n\n\t\t// If present, GLB container is required to be the first buffer.\n\t\tif ( bufferDef.uri === undefined && bufferIndex === 0 ) {\n\n\t\t\treturn Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );\n\n\t\t}\n\n\t\tconst options = this.options;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tloader.load( LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {\n\n\t\t\t\treject( new Error( 'THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".' ) );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferViewIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tloadBufferView( bufferViewIndex ) {\n\n\t\tconst bufferViewDef = this.json.bufferViews[ bufferViewIndex ];\n\n\t\treturn this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {\n\n\t\t\tconst byteLength = bufferViewDef.byteLength || 0;\n\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\treturn buffer.slice( byteOffset, byteOffset + byteLength );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n\t * @param {number} accessorIndex\n\t * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n\t */\n\tloadAccessor( accessorIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\n\t\tconst accessorDef = this.json.accessors[ accessorIndex ];\n\n\t\tif ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {\n\n\t\t\tconst itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\tconst TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\t\t\tconst normalized = accessorDef.normalized === true;\n\n\t\t\tconst array = new TypedArray( accessorDef.count * itemSize );\n\t\t\treturn Promise.resolve( new BufferAttribute( array, itemSize, normalized ) );\n\n\t\t}\n\n\t\tconst pendingBufferViews = [];\n\n\t\tif ( accessorDef.bufferView !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );\n\n\t\t} else {\n\n\t\t\tpendingBufferViews.push( null );\n\n\t\t}\n\n\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );\n\n\t\t}\n\n\t\treturn Promise.all( pendingBufferViews ).then( function ( bufferViews ) {\n\n\t\t\tconst bufferView = bufferViews[ 0 ];\n\n\t\t\tconst itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\tconst TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\t\t\tconst elementBytes = TypedArray.BYTES_PER_ELEMENT;\n\t\t\tconst itemBytes = elementBytes * itemSize;\n\t\t\tconst byteOffset = accessorDef.byteOffset || 0;\n\t\t\tconst byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;\n\t\t\tconst normalized = accessorDef.normalized === true;\n\t\t\tlet array, bufferAttribute;\n\n\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\n\t\t\tif ( byteStride && byteStride !== itemBytes ) {\n\n\t\t\t\t// Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n\t\t\t\t// This makes sure that IBA.count reflects accessor.count properly\n\t\t\t\tconst ibSlice = Math.floor( byteOffset / byteStride );\n\t\t\t\tconst ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\n\t\t\t\tlet ib = parser.cache.get( ibCacheKey );\n\n\t\t\t\tif ( ! ib ) {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );\n\n\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\n\t\t\t\t\tib = new InterleavedBuffer( array, byteStride / elementBytes );\n\n\t\t\t\t\tparser.cache.add( ibCacheKey, ib );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );\n\n\t\t\t} else {\n\n\t\t\t\tif ( bufferView === null ) {\n\n\t\t\t\t\tarray = new TypedArray( accessorDef.count * itemSize );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t\t\t}\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\t\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\t\tconst itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n\t\t\t\tconst TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];\n\n\t\t\t\tconst byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n\t\t\t\tconst byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n\n\t\t\t\tconst sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );\n\t\t\t\tconst sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );\n\n\t\t\t\tif ( bufferView !== null ) {\n\n\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n\t\t\t\t\tbufferAttribute = new BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst index = sparseIndices[ i ];\n\n\t\t\t\t\tbufferAttribute.setX( index, sparseValues[ i * itemSize ] );\n\t\t\t\t\tif ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );\n\t\t\t\t\tif ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );\n\t\t\t\t\tif ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );\n\t\t\t\t\tif ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bufferAttribute;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n\t * @param {number} textureIndex\n\t * @return {Promise<THREE.Texture|null>}\n\t */\n\tloadTexture( textureIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\t\tconst textureDef = json.textures[ textureIndex ];\n\t\tconst sourceIndex = textureDef.source;\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tlet loader = this.textureLoader;\n\n\t\tif ( sourceDef.uri ) {\n\n\t\t\tconst handler = options.manager.getHandler( sourceDef.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.loadTextureImage( textureIndex, sourceIndex, loader );\n\n\t}\n\n\tloadTextureImage( textureIndex, sourceIndex, loader ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tconst cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler;\n\n\t\tif ( this.textureCache[ cacheKey ] ) {\n\n\t\t\t// See https://github.com/mrdoob/three.js/issues/21559.\n\t\t\treturn this.textureCache[ cacheKey ];\n\n\t\t}\n\n\t\tconst promise = this.loadImageSource( sourceIndex, loader ).then( function ( texture ) {\n\n\t\t\ttexture.flipY = false;\n\n\t\t\ttexture.name = textureDef.name || sourceDef.name || '';\n\n\t\t\tconst samplers = json.samplers || {};\n\t\t\tconst sampler = samplers[ textureDef.sampler ] || {};\n\n\t\t\ttexture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;\n\t\t\ttexture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipmapLinearFilter;\n\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;\n\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;\n\n\t\t\tparser.associations.set( texture, { textures: textureIndex } );\n\n\t\t\treturn texture;\n\n\t\t} ).catch( function () {\n\n\t\t\treturn null;\n\n\t\t} );\n\n\t\tthis.textureCache[ cacheKey ] = promise;\n\n\t\treturn promise;\n\n\t}\n\n\tloadImageSource( sourceIndex, loader ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\n\t\tif ( this.sourceCache[ sourceIndex ] !== undefined ) {\n\n\t\t\treturn this.sourceCache[ sourceIndex ].then( ( texture ) => texture.clone() );\n\n\t\t}\n\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tconst URL = self.URL || self.webkitURL;\n\n\t\tlet sourceURI = sourceDef.uri || '';\n\t\tlet isObjectURL = false;\n\n\t\tif ( sourceDef.bufferView !== undefined ) {\n\n\t\t\t// Load binary image data from bufferView, if provided.\n\n\t\t\tsourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function ( bufferView ) {\n\n\t\t\t\tisObjectURL = true;\n\t\t\t\tconst blob = new Blob( [ bufferView ], { type: sourceDef.mimeType } );\n\t\t\t\tsourceURI = URL.createObjectURL( blob );\n\t\t\t\treturn sourceURI;\n\n\t\t\t} );\n\n\t\t} else if ( sourceDef.uri === undefined ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' );\n\n\t\t}\n\n\t\tconst promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {\n\n\t\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\t\tlet onLoad = resolve;\n\n\t\t\t\tif ( loader.isImageBitmapLoader === true ) {\n\n\t\t\t\t\tonLoad = function ( imageBitmap ) {\n\n\t\t\t\t\t\tconst texture = new Texture( imageBitmap );\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tresolve( texture );\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tloader.load( LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );\n\n\t\t\t} );\n\n\t\t} ).then( function ( texture ) {\n\n\t\t\t// Clean up resources and configure Texture.\n\n\t\t\tif ( isObjectURL === true ) {\n\n\t\t\t\tURL.revokeObjectURL( sourceURI );\n\n\t\t\t}\n\n\t\t\ttexture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType( sourceDef.uri );\n\n\t\t\treturn texture;\n\n\t\t} ).catch( function ( error ) {\n\n\t\t\tconsole.error( 'THREE.GLTFLoader: Couldn\\'t load texture', sourceURI );\n\t\t\tthrow error;\n\n\t\t} );\n\n\t\tthis.sourceCache[ sourceIndex ] = promise;\n\t\treturn promise;\n\n\t}\n\n\t/**\n\t * Asynchronously assigns a texture to the given material parameters.\n\t * @param {Object} materialParams\n\t * @param {string} mapName\n\t * @param {Object} mapDef\n\t * @return {Promise<Texture>}\n\t */\n\tassignTexture( materialParams, mapName, mapDef, encoding ) {\n\n\t\tconst parser = this;\n\n\t\treturn this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {\n\n\t\t\tif ( ! texture ) return null;\n\n\t\t\t// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured\n\t\t\t// However, we will copy UV set 0 to UV set 1 on demand for aoMap\n\t\t\tif ( mapDef.texCoord !== undefined && mapDef.texCoord != 0 && ! ( mapName === 'aoMap' && mapDef.texCoord == 1 ) ) {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.' );\n\n\t\t\t}\n\n\t\t\tif ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {\n\n\t\t\t\tconst transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;\n\n\t\t\t\tif ( transform ) {\n\n\t\t\t\t\tconst gltfReference = parser.associations.get( texture );\n\t\t\t\t\ttexture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );\n\t\t\t\t\tparser.associations.set( texture, gltfReference );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( encoding !== undefined ) {\n\n\t\t\t\ttexture.encoding = encoding;\n\n\t\t\t}\n\n\t\t\tmaterialParams[ mapName ] = texture;\n\n\t\t\treturn texture;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Assigns final material to a Mesh, Line, or Points instance. The instance\n\t * already has a material (generated from the glTF material options alone)\n\t * but reuse of the same glTF material may require multiple threejs materials\n\t * to accommodate different primitive types, defines, etc. New materials will\n\t * be created if necessary, and reused from a cache.\n\t * @param  {Object3D} mesh Mesh, Line, or Points instance.\n\t */\n\tassignFinalMaterial( mesh ) {\n\n\t\tconst geometry = mesh.geometry;\n\t\tlet material = mesh.material;\n\n\t\tconst useDerivativeTangents = geometry.attributes.tangent === undefined;\n\t\tconst useVertexColors = geometry.attributes.color !== undefined;\n\t\tconst useFlatShading = geometry.attributes.normal === undefined;\n\n\t\tif ( mesh.isPoints ) {\n\n\t\t\tconst cacheKey = 'PointsMaterial:' + material.uuid;\n\n\t\t\tlet pointsMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! pointsMaterial ) {\n\n\t\t\t\tpointsMaterial = new PointsMaterial();\n\t\t\t\tMaterial.prototype.copy.call( pointsMaterial, material );\n\t\t\t\tpointsMaterial.color.copy( material.color );\n\t\t\t\tpointsMaterial.map = material.map;\n\t\t\t\tpointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n\n\t\t\t\tthis.cache.add( cacheKey, pointsMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = pointsMaterial;\n\n\t\t} else if ( mesh.isLine ) {\n\n\t\t\tconst cacheKey = 'LineBasicMaterial:' + material.uuid;\n\n\t\t\tlet lineMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! lineMaterial ) {\n\n\t\t\t\tlineMaterial = new LineBasicMaterial();\n\t\t\t\tMaterial.prototype.copy.call( lineMaterial, material );\n\t\t\t\tlineMaterial.color.copy( material.color );\n\n\t\t\t\tthis.cache.add( cacheKey, lineMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = lineMaterial;\n\n\t\t}\n\n\t\t// Clone the material if it will be modified\n\t\tif ( useDerivativeTangents || useVertexColors || useFlatShading ) {\n\n\t\t\tlet cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n\n\t\t\tif ( useDerivativeTangents ) cacheKey += 'derivative-tangents:';\n\t\t\tif ( useVertexColors ) cacheKey += 'vertex-colors:';\n\t\t\tif ( useFlatShading ) cacheKey += 'flat-shading:';\n\n\t\t\tlet cachedMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! cachedMaterial ) {\n\n\t\t\t\tcachedMaterial = material.clone();\n\n\t\t\t\tif ( useVertexColors ) cachedMaterial.vertexColors = true;\n\t\t\t\tif ( useFlatShading ) cachedMaterial.flatShading = true;\n\n\t\t\t\tif ( useDerivativeTangents ) {\n\n\t\t\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\t\tif ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;\n\t\t\t\t\tif ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;\n\n\t\t\t\t}\n\n\t\t\t\tthis.cache.add( cacheKey, cachedMaterial );\n\n\t\t\t\tthis.associations.set( cachedMaterial, this.associations.get( material ) );\n\n\t\t\t}\n\n\t\t\tmaterial = cachedMaterial;\n\n\t\t}\n\n\t\t// workarounds for mesh and geometry\n\n\t\tif ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {\n\n\t\t\tgeometry.setAttribute( 'uv2', geometry.attributes.uv );\n\n\t\t}\n\n\t\tmesh.material = material;\n\n\t}\n\n\tgetMaterialType( /* materialIndex */ ) {\n\n\t\treturn MeshStandardMaterial;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n\t * @param {number} materialIndex\n\t * @return {Promise<Material>}\n\t */\n\tloadMaterial( materialIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\t\tconst materialDef = json.materials[ materialIndex ];\n\n\t\tlet materialType;\n\t\tconst materialParams = {};\n\t\tconst materialExtensions = materialDef.extensions || {};\n\n\t\tconst pending = [];\n\n\t\tif ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {\n\n\t\t\tconst kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];\n\t\t\tmaterialType = kmuExtension.getMaterialType();\n\t\t\tpending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t} else {\n\n\t\t\t// Specification:\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n\t\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness || {};\n\n\t\t\tmaterialParams.color = new Color( 1.0, 1.0, 1.0 );\n\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tconst array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, sRGBEncoding ) );\n\n\t\t\t}\n\n\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n\t\t\tif ( metallicRoughness.metallicRoughnessTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\n\t\t\t}\n\n\t\t\tmaterialType = this._invokeOne( function ( ext ) {\n\n\t\t\t\treturn ext.getMaterialType && ext.getMaterialType( materialIndex );\n\n\t\t\t} );\n\n\t\t\tpending.push( Promise.all( this._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );\n\n\t\t\t} ) ) );\n\n\t\t}\n\n\t\tif ( materialDef.doubleSided === true ) {\n\n\t\t\tmaterialParams.side = DoubleSide;\n\n\t\t}\n\n\t\tconst alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n\t\tif ( alphaMode === ALPHA_MODES.BLEND ) {\n\n\t\t\tmaterialParams.transparent = true;\n\n\t\t\t// See: https://github.com/mrdoob/three.js/issues/17706\n\t\t\tmaterialParams.depthWrite = false;\n\n\t\t} else {\n\n\t\t\tmaterialParams.transparent = false;\n\n\t\t\tif ( alphaMode === ALPHA_MODES.MASK ) {\n\n\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );\n\n\t\t\tmaterialParams.normalScale = new Vector2( 1, 1 );\n\n\t\t\tif ( materialDef.normalTexture.scale !== undefined ) {\n\n\t\t\t\tconst scale = materialDef.normalTexture.scale;\n\n\t\t\t\tmaterialParams.normalScale.set( scale, scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );\n\n\t\t\tif ( materialDef.occlusionTexture.strength !== undefined ) {\n\n\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tmaterialParams.emissive = new Color().fromArray( materialDef.emissiveFactor );\n\n\t\t}\n\n\t\tif ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture, sRGBEncoding ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\tconst material = new materialType( materialParams );\n\n\t\t\tif ( materialDef.name ) material.name = materialDef.name;\n\n\t\t\tassignExtrasToUserData( material, materialDef );\n\n\t\t\tparser.associations.set( material, { materials: materialIndex } );\n\n\t\t\tif ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );\n\n\t\t\treturn material;\n\n\t\t} );\n\n\t}\n\n\t/** When Object3D instances are targeted by animation, they need unique names. */\n\tcreateUniqueName( originalName ) {\n\n\t\tconst sanitizedName = PropertyBinding.sanitizeNodeName( originalName || '' );\n\n\t\tlet name = sanitizedName;\n\n\t\tfor ( let i = 1; this.nodeNamesUsed[ name ]; ++ i ) {\n\n\t\t\tname = sanitizedName + '_' + i;\n\n\t\t}\n\n\t\tthis.nodeNamesUsed[ name ] = true;\n\n\t\treturn name;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n\t *\n\t * Creates BufferGeometries from primitives.\n\t *\n\t * @param {Array<GLTF.Primitive>} primitives\n\t * @return {Promise<Array<BufferGeometry>>}\n\t */\n\tloadGeometries( primitives ) {\n\n\t\tconst parser = this;\n\t\tconst extensions = this.extensions;\n\t\tconst cache = this.primitiveCache;\n\n\t\tfunction createDracoPrimitive( primitive ) {\n\n\t\t\treturn extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]\n\t\t\t\t.decodePrimitive( primitive, parser )\n\t\t\t\t.then( function ( geometry ) {\n\n\t\t\t\t\treturn addPrimitiveAttributes( geometry, primitive, parser );\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tconst primitive = primitives[ i ];\n\t\t\tconst cacheKey = createPrimitiveKey( primitive );\n\n\t\t\t// See if we've already created this geometry\n\t\t\tconst cached = cache[ cacheKey ];\n\n\t\t\tif ( cached ) {\n\n\t\t\t\t// Use the cached geometry if it exists\n\t\t\t\tpending.push( cached.promise );\n\n\t\t\t} else {\n\n\t\t\t\tlet geometryPromise;\n\n\t\t\t\tif ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {\n\n\t\t\t\t\t// Use DRACO geometry if available\n\t\t\t\t\tgeometryPromise = createDracoPrimitive( primitive );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Otherwise create a new geometry\n\t\t\t\t\tgeometryPromise = addPrimitiveAttributes( new BufferGeometry(), primitive, parser );\n\n\t\t\t\t}\n\n\t\t\t\t// Cache this geometry\n\t\t\t\tcache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };\n\n\t\t\t\tpending.push( geometryPromise );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n\t * @param {number} meshIndex\n\t * @return {Promise<Group|Mesh|SkinnedMesh>}\n\t */\n\tloadMesh( meshIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\n\t\tconst meshDef = json.meshes[ meshIndex ];\n\t\tconst primitives = meshDef.primitives;\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tconst material = primitives[ i ].material === undefined\n\t\t\t\t? createDefaultMaterial( this.cache )\n\t\t\t\t: this.getDependency( 'material', primitives[ i ].material );\n\n\t\t\tpending.push( material );\n\n\t\t}\n\n\t\tpending.push( parser.loadGeometries( primitives ) );\n\n\t\treturn Promise.all( pending ).then( function ( results ) {\n\n\t\t\tconst materials = results.slice( 0, results.length - 1 );\n\t\t\tconst geometries = results[ results.length - 1 ];\n\n\t\t\tconst meshes = [];\n\n\t\t\tfor ( let i = 0, il = geometries.length; i < il; i ++ ) {\n\n\t\t\t\tconst geometry = geometries[ i ];\n\t\t\t\tconst primitive = primitives[ i ];\n\n\t\t\t\t// 1. create Mesh\n\n\t\t\t\tlet mesh;\n\n\t\t\t\tconst material = materials[ i ];\n\n\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n\t\t\t\t\t\tprimitive.mode === undefined ) {\n\n\t\t\t\t\t// .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n\t\t\t\t\tmesh = meshDef.isSkinnedMesh === true\n\t\t\t\t\t\t? new SkinnedMesh( geometry, material )\n\t\t\t\t\t\t: new Mesh( geometry, material );\n\n\t\t\t\t\tif ( mesh.isSkinnedMesh === true ) {\n\n\t\t\t\t\t\t// normalize skin weights to fix malformed assets (see #15319)\n\t\t\t\t\t\tmesh.normalizeSkinWeights();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleStripDrawMode );\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleFanDrawMode );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {\n\n\t\t\t\t\tmesh = new LineSegments( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {\n\n\t\t\t\t\tmesh = new Line( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {\n\n\t\t\t\t\tmesh = new LineLoop( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {\n\n\t\t\t\t\tmesh = new Points( geometry, material );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );\n\n\t\t\t\t}\n\n\t\t\t\tif ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {\n\n\t\t\t\t\tupdateMorphTargets( mesh, meshDef );\n\n\t\t\t\t}\n\n\t\t\t\tmesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );\n\n\t\t\t\tassignExtrasToUserData( mesh, meshDef );\n\n\t\t\t\tif ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );\n\n\t\t\t\tparser.assignFinalMaterial( mesh );\n\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\tparser.associations.set( meshes[ i ], {\n\t\t\t\t\tmeshes: meshIndex,\n\t\t\t\t\tprimitives: i\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( meshes.length === 1 ) {\n\n\t\t\t\treturn meshes[ 0 ];\n\n\t\t\t}\n\n\t\t\tconst group = new Group();\n\n\t\t\tparser.associations.set( group, { meshes: meshIndex } );\n\n\t\t\tfor ( let i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\tgroup.add( meshes[ i ] );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n\t * @param {number} cameraIndex\n\t * @return {Promise<THREE.Camera>}\n\t */\n\tloadCamera( cameraIndex ) {\n\n\t\tlet camera;\n\t\tconst cameraDef = this.json.cameras[ cameraIndex ];\n\t\tconst params = cameraDef[ cameraDef.type ];\n\n\t\tif ( ! params ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing camera parameters.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( cameraDef.type === 'perspective' ) {\n\n\t\t\tcamera = new PerspectiveCamera( MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );\n\n\t\t} else if ( cameraDef.type === 'orthographic' ) {\n\n\t\t\tcamera = new OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );\n\n\t\t}\n\n\t\tif ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );\n\n\t\tassignExtrasToUserData( camera, cameraDef );\n\n\t\treturn Promise.resolve( camera );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n\t * @param {number} skinIndex\n\t * @return {Promise<Skeleton>}\n\t */\n\tloadSkin( skinIndex ) {\n\n\t\tconst skinDef = this.json.skins[ skinIndex ];\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = skinDef.joints.length; i < il; i ++ ) {\n\n\t\t\tpending.push( this._loadNodeShallow( skinDef.joints[ i ] ) );\n\n\t\t}\n\n\t\tif ( skinDef.inverseBindMatrices !== undefined ) {\n\n\t\t\tpending.push( this.getDependency( 'accessor', skinDef.inverseBindMatrices ) );\n\n\t\t} else {\n\n\t\t\tpending.push( null );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function ( results ) {\n\n\t\t\tconst inverseBindMatrices = results.pop();\n\t\t\tconst jointNodes = results;\n\n\t\t\t// Note that bones (joint nodes) may or may not be in the\n\t\t\t// scene graph at this time.\n\n\t\t\tconst bones = [];\n\t\t\tconst boneInverses = [];\n\n\t\t\tfor ( let i = 0, il = jointNodes.length; i < il; i ++ ) {\n\n\t\t\t\tconst jointNode = jointNodes[ i ];\n\n\t\t\t\tif ( jointNode ) {\n\n\t\t\t\t\tbones.push( jointNode );\n\n\t\t\t\t\tconst mat = new Matrix4();\n\n\t\t\t\t\tif ( inverseBindMatrices !== null ) {\n\n\t\t\t\t\t\tmat.fromArray( inverseBindMatrices.array, i * 16 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneInverses.push( mat );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new Skeleton( bones, boneInverses );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n\t * @param {number} animationIndex\n\t * @return {Promise<AnimationClip>}\n\t */\n\tloadAnimation( animationIndex ) {\n\n\t\tconst json = this.json;\n\n\t\tconst animationDef = json.animations[ animationIndex ];\n\n\t\tconst pendingNodes = [];\n\t\tconst pendingInputAccessors = [];\n\t\tconst pendingOutputAccessors = [];\n\t\tconst pendingSamplers = [];\n\t\tconst pendingTargets = [];\n\n\t\tfor ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {\n\n\t\t\tconst channel = animationDef.channels[ i ];\n\t\t\tconst sampler = animationDef.samplers[ channel.sampler ];\n\t\t\tconst target = channel.target;\n\t\t\tconst name = target.node;\n\t\t\tconst input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;\n\t\t\tconst output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;\n\n\t\t\tpendingNodes.push( this.getDependency( 'node', name ) );\n\t\t\tpendingInputAccessors.push( this.getDependency( 'accessor', input ) );\n\t\t\tpendingOutputAccessors.push( this.getDependency( 'accessor', output ) );\n\t\t\tpendingSamplers.push( sampler );\n\t\t\tpendingTargets.push( target );\n\n\t\t}\n\n\t\treturn Promise.all( [\n\n\t\t\tPromise.all( pendingNodes ),\n\t\t\tPromise.all( pendingInputAccessors ),\n\t\t\tPromise.all( pendingOutputAccessors ),\n\t\t\tPromise.all( pendingSamplers ),\n\t\t\tPromise.all( pendingTargets )\n\n\t\t] ).then( function ( dependencies ) {\n\n\t\t\tconst nodes = dependencies[ 0 ];\n\t\t\tconst inputAccessors = dependencies[ 1 ];\n\t\t\tconst outputAccessors = dependencies[ 2 ];\n\t\t\tconst samplers = dependencies[ 3 ];\n\t\t\tconst targets = dependencies[ 4 ];\n\n\t\t\tconst tracks = [];\n\n\t\t\tfor ( let i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\tconst node = nodes[ i ];\n\t\t\t\tconst inputAccessor = inputAccessors[ i ];\n\t\t\t\tconst outputAccessor = outputAccessors[ i ];\n\t\t\t\tconst sampler = samplers[ i ];\n\t\t\t\tconst target = targets[ i ];\n\n\t\t\t\tif ( node === undefined ) continue;\n\n\t\t\t\tnode.updateMatrix();\n\n\t\t\t\tlet TypedKeyframeTrack;\n\n\t\t\t\tswitch ( PATH_PROPERTIES[ target.path ] ) {\n\n\t\t\t\t\tcase PATH_PROPERTIES.weights:\n\n\t\t\t\t\t\tTypedKeyframeTrack = NumberKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase PATH_PROPERTIES.rotation:\n\n\t\t\t\t\t\tTypedKeyframeTrack = QuaternionKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase PATH_PROPERTIES.position:\n\t\t\t\t\tcase PATH_PROPERTIES.scale:\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tTypedKeyframeTrack = VectorKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tconst targetName = node.name ? node.name : node.uuid;\n\n\t\t\t\tconst interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;\n\n\t\t\t\tconst targetNames = [];\n\n\t\t\t\tif ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {\n\n\t\t\t\t\tnode.traverse( function ( object ) {\n\n\t\t\t\t\t\tif ( object.morphTargetInfluences ) {\n\n\t\t\t\t\t\t\ttargetNames.push( object.name ? object.name : object.uuid );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetNames.push( targetName );\n\n\t\t\t\t}\n\n\t\t\t\tlet outputArray = outputAccessor.array;\n\n\t\t\t\tif ( outputAccessor.normalized ) {\n\n\t\t\t\t\tconst scale = getNormalizedComponentScale( outputArray.constructor );\n\t\t\t\t\tconst scaled = new Float32Array( outputArray.length );\n\n\t\t\t\t\tfor ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tscaled[ j ] = outputArray[ j ] * scale;\n\n\t\t\t\t\t}\n\n\t\t\t\t\toutputArray = scaled;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst track = new TypedKeyframeTrack(\n\t\t\t\t\t\ttargetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],\n\t\t\t\t\t\tinputAccessor.array,\n\t\t\t\t\t\toutputArray,\n\t\t\t\t\t\tinterpolation\n\t\t\t\t\t);\n\n\t\t\t\t\t// Override interpolation with custom factory method.\n\t\t\t\t\tif ( sampler.interpolation === 'CUBICSPLINE' ) {\n\n\t\t\t\t\t\ttrack.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {\n\n\t\t\t\t\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\n\t\t\t\t\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n\t\t\t\t\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\n\n\t\t\t\t\t\t\tconst interpolantType = ( this instanceof QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n\n\t\t\t\t\t\t\treturn new interpolantType( this.times, this.values, this.getValueSize() / 3, result );\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\t\t\t\t\t\ttrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( track );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\n\n\t\t\treturn new AnimationClip( name, undefined, tracks );\n\n\t\t} );\n\n\t}\n\n\tcreateNodeMesh( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tif ( nodeDef.mesh === undefined ) return null;\n\n\t\treturn parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {\n\n\t\t\tconst node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );\n\n\t\t\t// if weights are provided on the node, override weights on the mesh.\n\t\t\tif ( nodeDef.weights !== undefined ) {\n\n\t\t\t\tnode.traverse( function ( o ) {\n\n\t\t\t\t\tif ( ! o.isMesh ) return;\n\n\t\t\t\t\tfor ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {\n\n\t\t\t\t\t\to.morphTargetInfluences[ i ] = nodeDef.weights[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n\t * @param {number} nodeIndex\n\t * @return {Promise<Object3D>}\n\t */\n\tloadNode( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tconst nodePending = parser._loadNodeShallow( nodeIndex );\n\n\t\tconst childPending = [];\n\t\tconst childrenDef = nodeDef.children || [];\n\n\t\tfor ( let i = 0, il = childrenDef.length; i < il; i ++ ) {\n\n\t\t\tchildPending.push( parser.getDependency( 'node', childrenDef[ i ] ) );\n\n\t\t}\n\n\t\tconst skeletonPending = nodeDef.skin === undefined\n\t\t\t? Promise.resolve( null )\n\t\t\t: parser.getDependency( 'skin', nodeDef.skin );\n\n\t\treturn Promise.all( [\n\t\t\tnodePending,\n\t\t\tPromise.all( childPending ),\n\t\t\tskeletonPending\n\t\t] ).then( function ( results ) {\n\n\t\t\tconst node = results[ 0 ];\n\t\t\tconst children = results[ 1 ];\n\t\t\tconst skeleton = results[ 2 ];\n\n\t\t\tif ( skeleton !== null ) {\n\n\t\t\t\t// This full traverse should be fine because\n\t\t\t\t// child glTF nodes have not been added to this node yet.\n\t\t\t\tnode.traverse( function ( mesh ) {\n\n\t\t\t\t\tif ( ! mesh.isSkinnedMesh ) return;\n\n\t\t\t\t\tmesh.bind( skeleton, _identityMatrix );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, il = children.length; i < il; i ++ ) {\n\n\t\t\t\tnode.add( children[ i ] );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t}\n\n\t// ._loadNodeShallow() parses a single node.\n\t// skin and child nodes are created and added in .loadNode() (no '_' prefix).\n\t_loadNodeShallow( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\t\tconst parser = this;\n\n\t\t// This method is called from .loadNode() and .loadSkin().\n\t\t// Cache a node to avoid duplication.\n\n\t\tif ( this.nodeCache[ nodeIndex ] !== undefined ) {\n\n\t\t\treturn this.nodeCache[ nodeIndex ];\n\n\t\t}\n\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\t// reserve node's name before its dependencies, so the root has the intended name.\n\t\tconst nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';\n\n\t\tconst pending = [];\n\n\t\tconst meshPromise = parser._invokeOne( function ( ext ) {\n\n\t\t\treturn ext.createNodeMesh && ext.createNodeMesh( nodeIndex );\n\n\t\t} );\n\n\t\tif ( meshPromise ) {\n\n\t\t\tpending.push( meshPromise );\n\n\t\t}\n\n\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\tpending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {\n\n\t\t\t\treturn parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );\n\n\t\t\t} ) );\n\n\t\t}\n\n\t\tparser._invokeAll( function ( ext ) {\n\n\t\t\treturn ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );\n\n\t\t} ).forEach( function ( promise ) {\n\n\t\t\tpending.push( promise );\n\n\t\t} );\n\n\t\tthis.nodeCache[ nodeIndex ] = Promise.all( pending ).then( function ( objects ) {\n\n\t\t\tlet node;\n\n\t\t\t// .isBone isn't in glTF spec. See ._markDefs\n\t\t\tif ( nodeDef.isBone === true ) {\n\n\t\t\t\tnode = new Bone();\n\n\t\t\t} else if ( objects.length > 1 ) {\n\n\t\t\t\tnode = new Group();\n\n\t\t\t} else if ( objects.length === 1 ) {\n\n\t\t\t\tnode = objects[ 0 ];\n\n\t\t\t} else {\n\n\t\t\t\tnode = new Object3D();\n\n\t\t\t}\n\n\t\t\tif ( node !== objects[ 0 ] ) {\n\n\t\t\t\tfor ( let i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\t\t\tnode.add( objects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.name ) {\n\n\t\t\t\tnode.userData.name = nodeDef.name;\n\t\t\t\tnode.name = nodeName;\n\n\t\t\t}\n\n\t\t\tassignExtrasToUserData( node, nodeDef );\n\n\t\t\tif ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );\n\n\t\t\tif ( nodeDef.matrix !== undefined ) {\n\n\t\t\t\tconst matrix = new Matrix4();\n\t\t\t\tmatrix.fromArray( nodeDef.matrix );\n\t\t\t\tnode.applyMatrix4( matrix );\n\n\t\t\t} else {\n\n\t\t\t\tif ( nodeDef.translation !== undefined ) {\n\n\t\t\t\t\tnode.position.fromArray( nodeDef.translation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.rotation !== undefined ) {\n\n\t\t\t\t\tnode.quaternion.fromArray( nodeDef.rotation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.scale !== undefined ) {\n\n\t\t\t\t\tnode.scale.fromArray( nodeDef.scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! parser.associations.has( node ) ) {\n\n\t\t\t\tparser.associations.set( node, {} );\n\n\t\t\t}\n\n\t\t\tparser.associations.get( node ).nodes = nodeIndex;\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t\treturn this.nodeCache[ nodeIndex ];\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n\t * @param {number} sceneIndex\n\t * @return {Promise<Group>}\n\t */\n\tloadScene( sceneIndex ) {\n\n\t\tconst extensions = this.extensions;\n\t\tconst sceneDef = this.json.scenes[ sceneIndex ];\n\t\tconst parser = this;\n\n\t\t// Loader returns Group, not Scene.\n\t\t// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n\t\tconst scene = new Group();\n\t\tif ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );\n\n\t\tassignExtrasToUserData( scene, sceneDef );\n\n\t\tif ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );\n\n\t\tconst nodeIds = sceneDef.nodes || [];\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = nodeIds.length; i < il; i ++ ) {\n\n\t\t\tpending.push( parser.getDependency( 'node', nodeIds[ i ] ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function ( nodes ) {\n\n\t\t\tfor ( let i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\tscene.add( nodes[ i ] );\n\n\t\t\t}\n\n\t\t\t// Removes dangling associations, associations that reference a node that\n\t\t\t// didn't make it into the scene.\n\t\t\tconst reduceAssociations = ( node ) => {\n\n\t\t\t\tconst reducedAssociations = new Map();\n\n\t\t\t\tfor ( const [ key, value ] of parser.associations ) {\n\n\t\t\t\t\tif ( key instanceof Material || key instanceof Texture ) {\n\n\t\t\t\t\t\treducedAssociations.set( key, value );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tnode.traverse( ( node ) => {\n\n\t\t\t\t\tconst mappings = parser.associations.get( node );\n\n\t\t\t\t\tif ( mappings != null ) {\n\n\t\t\t\t\t\treducedAssociations.set( node, mappings );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn reducedAssociations;\n\n\t\t\t};\n\n\t\t\tparser.associations = reduceAssociations( scene );\n\n\t\t\treturn scene;\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n */\nfunction computeBounds( geometry, primitiveDef, parser ) {\n\n\tconst attributes = primitiveDef.attributes;\n\n\tconst box = new Box3();\n\n\tif ( attributes.POSITION !== undefined ) {\n\n\t\tconst accessor = parser.json.accessors[ attributes.POSITION ];\n\n\t\tconst min = accessor.min;\n\t\tconst max = accessor.max;\n\n\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\tbox.set(\n\t\t\t\tnew Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),\n\t\t\t\tnew Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )\n\t\t\t);\n\n\t\t\tif ( accessor.normalized ) {\n\n\t\t\t\tconst boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );\n\t\t\t\tbox.min.multiplyScalar( boxScale );\n\t\t\t\tbox.max.multiplyScalar( boxScale );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\treturn;\n\n\t\t}\n\n\t} else {\n\n\t\treturn;\n\n\t}\n\n\tconst targets = primitiveDef.targets;\n\n\tif ( targets !== undefined ) {\n\n\t\tconst maxDisplacement = new Vector3();\n\t\tconst vector = new Vector3();\n\n\t\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\tconst target = targets[ i ];\n\n\t\t\tif ( target.POSITION !== undefined ) {\n\n\t\t\t\tconst accessor = parser.json.accessors[ target.POSITION ];\n\t\t\t\tconst min = accessor.min;\n\t\t\t\tconst max = accessor.max;\n\n\t\t\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\t\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\t\t\t// we need to get max of absolute components because target weight is [-1,1]\n\t\t\t\t\tvector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );\n\t\t\t\t\tvector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );\n\t\t\t\t\tvector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );\n\n\n\t\t\t\t\tif ( accessor.normalized ) {\n\n\t\t\t\t\t\tconst boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );\n\t\t\t\t\t\tvector.multiplyScalar( boxScale );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n\t\t\t\t\t// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n\t\t\t\t\t// are used to implement key-frame animations and as such only two are active at a time - this results in very large\n\t\t\t\t\t// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n\t\t\t\t\tmaxDisplacement.max( vector );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n\t\tbox.expandByVector( maxDisplacement );\n\n\t}\n\n\tgeometry.boundingBox = box;\n\n\tconst sphere = new Sphere();\n\n\tbox.getCenter( sphere.center );\n\tsphere.radius = box.min.distanceTo( box.max ) / 2;\n\n\tgeometry.boundingSphere = sphere;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addPrimitiveAttributes( geometry, primitiveDef, parser ) {\n\n\tconst attributes = primitiveDef.attributes;\n\n\tconst pending = [];\n\n\tfunction assignAttributeAccessor( accessorIndex, attributeName ) {\n\n\t\treturn parser.getDependency( 'accessor', accessorIndex )\n\t\t\t.then( function ( accessor ) {\n\n\t\t\t\tgeometry.setAttribute( attributeName, accessor );\n\n\t\t\t} );\n\n\t}\n\n\tfor ( const gltfAttributeName in attributes ) {\n\n\t\tconst threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();\n\n\t\t// Skip attributes already provided by e.g. Draco extension.\n\t\tif ( threeAttributeName in geometry.attributes ) continue;\n\n\t\tpending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );\n\n\t}\n\n\tif ( primitiveDef.indices !== undefined && ! geometry.index ) {\n\n\t\tconst accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {\n\n\t\t\tgeometry.setIndex( accessor );\n\n\t\t} );\n\n\t\tpending.push( accessor );\n\n\t}\n\n\tassignExtrasToUserData( geometry, primitiveDef );\n\n\tcomputeBounds( geometry, primitiveDef, parser );\n\n\treturn Promise.all( pending ).then( function () {\n\n\t\treturn primitiveDef.targets !== undefined\n\t\t\t? addMorphTargets( geometry, primitiveDef.targets, parser )\n\t\t\t: geometry;\n\n\t} );\n\n}\n\nexport { GLTFLoader };\n"],"names":["_taskCache","WeakMap","DRACOLoader","three__WEBPACK_IMPORTED_MODULE_0__","Loader","constructor","manager","decoderPath","decoderConfig","decoderBinary","decoderPending","workerLimit","workerPool","workerNextTaskID","workerSourceURL","defaultAttributeIDs","position","normal","color","uv","defaultAttributeTypes","setDecoderPath","path","setDecoderConfig","config","setWorkerLimit","load","url","onLoad","onProgress","onError","loader","FileLoader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","parse","buffer","decodeDracoFile","SRGBColorSpace","catch","callback","attributeIDs","attributeTypes","vertexColorSpace","LinearSRGBColorSpace","taskConfig","useUniqueIDs","decodeGeometry","then","worker","taskKey","JSON","stringify","has","cachedTask","get","key","promise","byteLength","taskID","taskCost","geometryPending","_getWorker","_worker","Promise","resolve","reject","_callbacks","postMessage","type","id","_createGeometry","message","geometry","_releaseTask","set","geometryData","BufferGeometry","index","setIndex","BufferAttribute","array","i","attributes","length","result","name","itemSize","attribute","_assignVertexColorSpace","setAttribute","inputColorSpace","_color","Color","il","count","fromBufferAttribute","convertSRGBToLinear","setXYZ","r","g","b","_loadLibrary","responseType","undefined","preload","_initDecoder","useJS","WebAssembly","librariesPending","push","all","jsContent","libraries","wasmBinary","fn","DRACOWorker","toString","body","substring","indexOf","lastIndexOf","join","URL","createObjectURL","Blob","Worker","_taskCosts","_taskLoad","onmessage","e","data","console","error","sort","a","debug","log","map","dispose","terminate","revokeObjectURL","onModuleLoaded","draco","DracoDecoderModule","module","decoder","Decoder","dracoGeometry","decodingStatus","geometryType","GetEncodedGeometryType","TRIANGULAR_MESH","Mesh","DecodeArrayToMesh","POINT_CLOUD","PointCloud","DecodeArrayToPointCloud","ok","ptr","error_msg","attributeName","attributeID","attributeType","self","GetAttributeByUniqueId","GetAttributeId","GetAttribute","attributeResult","decodeAttribute","numComponents","num_components","numPoints","num_points","numValues","BYTES_PER_ELEMENT","dataType","getDracoDataType","Float32Array","DT_FLOAT32","Int8Array","DT_INT8","Int16Array","DT_INT16","Int32Array","DT_INT32","Uint8Array","DT_UINT8","Uint16Array","DT_UINT16","Uint32Array","DT_UINT32","_malloc","GetAttributeDataArrayForAllPoints","HEAPF32","slice","_free","decodeIndex","numFaces","num_faces","numIndices","GetTrianglesUInt32Array","destroy","buffers","attr","toTrianglesDrawMode","drawMode","three_module","TrianglesDrawMode","warn","TriangleFanDrawMode","TriangleStripDrawMode","getIndex","indices","getAttribute","numberOfTriangles","newIndices","getX","newGeometry","clone","clearGroups","GLTFLoader","dracoLoader","ktx2Loader","meshoptDecoder","pluginCallbacks","register","parser","GLTFMaterialsClearcoatExtension","GLTFTextureBasisUExtension","GLTFTextureWebPExtension","GLTFTextureAVIFExtension","GLTFMaterialsSheenExtension","GLTFMaterialsTransmissionExtension","GLTFMaterialsVolumeExtension","GLTFMaterialsIorExtension","GLTFMaterialsEmissiveStrengthExtension","GLTFMaterialsSpecularExtension","GLTFMaterialsIridescenceExtension","GLTFLightsExtension","GLTFMeshoptCompression","GLTFMeshGpuInstancing","resourcePath","scope","LoaderUtils","extractUrlBase","itemStart","_onError","itemError","itemEnd","gltf","setDRACOLoader","setDDSLoader","setKTX2Loader","setMeshoptDecoder","unregister","splice","json","extensions","plugins","textDecoder","TextDecoder","ArrayBuffer","magic","decode","BINARY_EXTENSION_HEADER_MAGIC","EXTENSIONS","KHR_BINARY_GLTF","GLTFBinaryExtension","content","asset","version","GLTFParser","crossOrigin","fileLoader","plugin","extensionsUsed","extensionName","extensionsRequired","KHR_MATERIALS_UNLIT","GLTFMaterialsUnlitExtension","KHR_DRACO_MESH_COMPRESSION","GLTFDracoMeshCompressionExtension","KHR_TEXTURE_TRANSFORM","GLTFTextureTransformExtension","KHR_MESH_QUANTIZATION","GLTFMeshQuantizationExtension","setExtensions","setPlugins","parseAsync","GLTFRegistry","objects","add","object","remove","removeAll","KHR_LIGHTS_PUNCTUAL","KHR_MATERIALS_CLEARCOAT","KHR_MATERIALS_IOR","KHR_MATERIALS_SHEEN","KHR_MATERIALS_SPECULAR","KHR_MATERIALS_TRANSMISSION","KHR_MATERIALS_IRIDESCENCE","KHR_MATERIALS_VOLUME","KHR_TEXTURE_BASISU","KHR_MATERIALS_EMISSIVE_STRENGTH","EXT_TEXTURE_WEBP","EXT_TEXTURE_AVIF","EXT_MESHOPT_COMPRESSION","EXT_MESH_GPU_INSTANCING","cache","refs","uses","_markDefs","nodeDefs","nodes","nodeIndex","nodeLength","nodeDef","light","_addNodeRef","_loadLight","lightIndex","lightNode","cacheKey","dependency","lightDefs","lights","lightDef","fromArray","range","DirectionalLight","target","PointLight","distance","SpotLight","spot","innerConeAngle","outerConeAngle","Math","PI","angle","penumbra","decay","assignExtrasToUserData","intensity","createUniqueName","getDependency","createNodeAttachment","_getNodeRef","getMaterialType","MeshBasicMaterial","extendParams","materialParams","materialDef","pending","opacity","metallicRoughness","pbrMetallicRoughness","Array","isArray","baseColorFactor","baseColorTexture","assignTexture","sRGBEncoding","extendMaterialParams","materialIndex","materials","emissiveStrength","emissiveIntensity","MeshPhysicalMaterial","extension","clearcoatFactor","clearcoat","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughness","clearcoatRoughnessTexture","clearcoatNormalTexture","scale","clearcoatNormalScale","Vector2","iridescenceFactor","iridescence","iridescenceTexture","iridescenceIor","iridescenceIOR","iridescenceThicknessRange","iridescenceThicknessMinimum","iridescenceThicknessMaximum","iridescenceThicknessTexture","sheenColor","sheenRoughness","sheen","sheenColorFactor","sheenRoughnessFactor","sheenColorTexture","sheenRoughnessTexture","transmissionFactor","transmission","transmissionTexture","thickness","thicknessFactor","thicknessTexture","attenuationDistance","Infinity","colorArray","attenuationColor","ior","specularIntensity","specularFactor","specularTexture","specularColorFactor","specularColor","specularColorTexture","loadTexture","textureIndex","textureDef","textures","options","loadTextureImage","source","isSupported","images","textureLoader","uri","handler","getHandler","detectSupport","image","Image","src","onload","onerror","height","loadBufferView","bufferView","bufferViews","extensionDef","supported","res","byteOffset","stride","byteStride","decodeGltfBufferAsync","mode","filter","ready","decodeGltfBuffer","createNodeMesh","mesh","meshDef","meshes","primitive","primitives","WEBGL_CONSTANTS","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","attributesDef","accessor","results","nodeObject","pop","isGroup","children","instancedMeshes","m","Matrix4","p","Vector3","q","Quaternion","s","instancedMesh","InstancedMesh","material","TRANSLATION","ROTATION","SCALE","setMatrixAt","compose","Object3D","prototype","copy","call","frustumCulled","assignFinalMaterial","clear","BINARY_EXTENSION_CHUNK_TYPES","BIN","headerView","DataView","header","getUint32","chunkContentsLength","chunkView","chunkIndex","chunkLength","chunkType","contentArray","BINARY_EXTENSION_HEADER_LENGTH","decodePrimitive","bufferViewIndex","gltfAttributeMap","threeAttributeMap","attributeNormalizedMap","attributeTypeMap","threeAttributeName","ATTRIBUTES","toLowerCase","accessorDef","accessors","componentType","WEBGL_COMPONENT_TYPES","normalized","extendTexture","texture","transform","texCoord","offset","rotation","repeat","needsUpdate","GLTFCubicSplineInterpolant","Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","copySampleValue_","values","valueSize","interpolate_","i1","t0","t","t1","stride2","stride3","td","pp","ppp","offset1","offset0","s2","s3","s0","s1","p0","m0","p1","m1","_q","GLTFCubicSplineQuaternionInterpolant","normalize","toArray","FLOAT","FLOAT_MAT3","FLOAT_MAT4","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","LINEAR","REPEAT","SAMPLER_2D","POINTS","LINES","LINE_LOOP","LINE_STRIP","UNSIGNED_BYTE","UNSIGNED_SHORT","WEBGL_FILTERS","NearestFilter","LinearFilter","NearestMipmapNearestFilter","LinearMipmapNearestFilter","NearestMipmapLinearFilter","LinearMipmapLinearFilter","WEBGL_WRAPPINGS","ClampToEdgeWrapping","MirroredRepeatWrapping","RepeatWrapping","WEBGL_TYPE_SIZES","POSITION","NORMAL","TANGENT","TEXCOORD_0","TEXCOORD_1","COLOR_0","WEIGHTS_0","JOINTS_0","PATH_PROPERTIES","translation","weights","INTERPOLATION","CUBICSPLINE","InterpolateLinear","STEP","InterpolateDiscrete","ALPHA_MODES","OPAQUE","MASK","BLEND","addUnknownExtensionsToUserData","knownExtensions","objectDef","userData","gltfExtensions","gltfDef","extras","Object","assign","createAttributesKey","attributesKey","keys","getNormalizedComponentScale","_identityMatrix","associations","Map","primitiveCache","nodeCache","meshCache","cameraCache","lightCache","sourceCache","textureCache","nodeNamesUsed","isSafari","isFirefox","firefoxVersion","navigator","test","userAgent","match","createImageBitmap","TextureLoader","ImageBitmapLoader","setCrossOrigin","_invokeAll","ext","beforeRoot","getDependencies","dependencies","scene","scenes","animations","cameras","afterRoot","skinDefs","skins","meshDefs","skinIndex","skinLength","joints","isBone","skin","isSkinnedMesh","camera","ref","updateMappings","original","mappings","child","entries","_invokeOne","func","unshift","loadScene","loadNode","loadMesh","loadAccessor","loadBuffer","loadMaterial","loadSkin","loadAnimation","loadCamera","defs","def","bufferIndex","bufferDef","resolveURL","bufferViewDef","accessorIndex","sparse","TypedArray","pendingBufferViews","bufferAttribute","elementBytes","ibSlice","floor","ibCacheKey","ib","InterleavedBuffer","InterleavedBufferAttribute","itemSizeIndices","SCALAR","TypedArrayIndices","byteOffsetIndices","byteOffsetValues","sparseIndices","sparseValues","setX","setY","setZ","setW","sourceIndex","sourceDef","sampler","loadImageSource","flipY","samplers","magFilter","minFilter","wrapS","wrapT","webkitURL","sourceURI","isObjectURL","blob","mimeType","isImageBitmapLoader","imageBitmap","Texture","search","mapName","mapDef","encoding","gltfReference","useDerivativeTangents","tangent","useVertexColors","useFlatShading","isPoints","uuid","pointsMaterial","PointsMaterial","Material","sizeAttenuation","isLine","lineMaterial","LineBasicMaterial","cachedMaterial","vertexColors","flatShading","normalScale","y","aoMap","uv2","MeshStandardMaterial","materialType","materialExtensions","kmuExtension","metalness","metallicFactor","roughness","roughnessFactor","metallicRoughnessTexture","doubleSided","side","DoubleSide","alphaMode","transparent","depthWrite","alphaTest","alphaCutoff","normalTexture","occlusionTexture","strength","aoMapIntensity","emissiveFactor","emissive","emissiveTexture","originalName","sanitizedName","PropertyBinding","sanitizeNodeName","loadGeometries","createPrimitiveKey","primitiveDef","dracoExtension","cached","geometryPromise","createDracoPrimitive","addPrimitiveAttributes","meshIndex","depthTest","FrontSide","geometries","SkinnedMesh","normalizeSkinWeights","LineSegments","Line","LineLoop","Points","morphAttributes","updateMorphTargets","morphTargetInfluences","targetNames","morphTargetDictionary","group","Group","cameraIndex","cameraDef","params","PerspectiveCamera","MathUtils","radToDeg","yfov","aspectRatio","znear","zfar","OrthographicCamera","xmag","ymag","skinDef","_loadNodeShallow","inverseBindMatrices","bones","boneInverses","jointNodes","jointNode","mat","Skeleton","animationIndex","animationDef","pendingNodes","pendingInputAccessors","pendingOutputAccessors","pendingSamplers","pendingTargets","channels","channel","node","input","parameters","output","inputAccessors","outputAccessors","targets","tracks","TypedKeyframeTrack","inputAccessor","outputAccessor","updateMatrix","NumberKeyframeTrack","QuaternionKeyframeTrack","VectorKeyframeTrack","targetName","interpolation","traverse","outputArray","scaled","j","jl","track","createInterpolant","interpolantType","times","getValueSize","isInterpolantFactoryMethodGLTFCubicSpline","AnimationClip","o","isMesh","nodePending","childPending","childrenDef","skeletonPending","skeleton","bind","nodeName","meshPromise","forEach","Bone","matrix","applyMatrix4","quaternion","sceneIndex","sceneDef","nodeIds","reduceAssociations","reducedAssociations","value","gltfAttributeName","assignAttributeAccessor","computeBounds","box","Box3","min","max","boxScale","multiplyScalar","maxDisplacement","vector","abs","expandByVector","boundingBox","sphere","Sphere","getCenter","center","radius","distanceTo","boundingSphere","addMorphTargets","hasMorphPosition","hasMorphNormal","hasMorphColor","pendingPositionAccessors","pendingNormalAccessors","pendingColorAccessors","pendingAccessor","morphPositions","morphNormals","morphColors","morphTargetsRelative"],"sourceRoot":""}